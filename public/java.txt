# 面向对象基础

## 类

1. 类就是具有<u>相同</u>的**属性**和**功能**的**对象**的**抽象**的集合
2. 类名称的首字母要大写
3. 对外公开的方法要用 `pubilc` 修饰符

```java
// 'class' 是表示定义类的关键字
// 'Cat' 是类名称
public class Cat {
    // 'shout' 是类方法
    public String shout() {
        return '喵'
    }
}
```



## 实例

1. 实例，就是一个真实的对象
2. 实例化就是创建对象的过程，使用`new`关键字来创建

```java
Cat cat = new Cat() // 声明Cat对象并实例化
```



## 构造方法

1. 构造方法，又叫构造函数，<u>其实就是对类进行初始化</u>。
2. 构造方法与类同名，无返回值，也不需要`void`，在`new`的时候调用。
3. 所有类都有构造方法，如果你不编码则系统默认生成空的构造方法，若你有定义的构造方法，那么默认的构造方法就会失效

```java
public class Cat {
    // 声明私有变量
    private String name = "";
    // 定义Cat的构造方法
    public Cat(String name) {
        // 将参数赋值给私有变量name
        this.name = name;
    }
    public String shout() {
        return '喵'
    }
}
```



## 方法重载

1. 方法重载提供了创建同名的多个方法的能力，但这些方法需使用不同的参数类型
2. 方法重载时，<u>两个方法必须要方法名相同</u>，<u>但参数类型或个数必须要有所不同</u>，否则重载就没有意义

```java
public class Cat {
    private String name = "";
    public Cat(String name) {
        this.name = name;
    }
    // 将构造方法重载
    public Cat() {
        this.name = '无名'
    }
    public String shout() {
        return '喵'
    }
}
```



## 属性与修饰符

1. 属性是一个方法或一对方法，即属性适合于以字段的方式使用方法调用的场合。
2. 字段是存储类要满足其设计所需要的数据，字段是与类相关的变量。

```java
public class Cat {
    private String name = "";
    // 定义私有变量，外界无法访问
    private int shoutnum = 3;
    // 表示外界可以访问内部私有变量shoutnum，如果没有setShoutnum则说明这个变量只读
    public void setShoutnum(int value) {
        this.shoutnum = value
    }
    // 表示外界可以设置内部私有变量shoutnum
    public int getShoutnum(int value) {
        return this.shoutnum
    }
    // ...
}
```



## 面向对象的三大特性

### 封装

1. 每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。
2. 良好的封装能够减少耦合
3. 类内部的实现可以自由地修改
4. 类具有清晰的对外接口



### 继承

1. 如果子类继承于父类，

   1. 子类拥有父类非`private`的属性和功能
   2. 子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能
   3. 子类还可以以自己的方式实现父类的功能（方法重写）

2. `protected`表示继承时子类可以对基类有完全访问权，也就是说用 `protected`修饰的类成员对子类公开但不对其他类公开

3. 子类从它的父类中继承的成员有方法、属性等，但对于构造方法有一些特殊，它不能被继承只能被调用。对于调用父类的成员，可以用 `base` 关键字

   ```java
   public class Animal {
       // name 对子类公开但不对其他类公开
       protected String name = "";
       public Animal(String name) {
           this.name = name;
       }
       public Animal() {
           this.name = "无名";
       }
       // shoutNum 对子类公开但不对其他类公开
       protected int shoutNum = 3;
       public void setShoutNum(int value) {
           this.shoutNum = value;
       }
       public int getShoutNum() {
           return this.shoutNum;
       }
       public String shout() {
           return "";
       }
   }
   ```

   ```java
   public class Cat extends Animal {
       
       public Cat() {
           super();
       }
       
       public Cat(String name) {
           super(name);
       }
       
       public String shout() {
           String result = "";
           for(int i=0; i < this.shoutNum; i++) {
               result += "喵";
           }
           return "我的名字叫"
       }
   }
   ```

4. 继承是有缺点的，那就是父类变，则子类不得不变

5. 继承会破坏封装，父类实现细节暴露给子类，这其实是增大了两个类之间的耦合性，所以继承是一种类与类之间强耦合的关系

6. 当两个类之间具备 **is-a** 的关系时，就可以考虑用继承



### 多态

1. 多态表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行，就比如：老鹰展开翅膀用来更高更远地飞翔，鸵鸟用来更快更稳地奔跑， 而企鹅则是更急更流畅地游泳。
2. 子类以父类的身份出现
3. 子类在工作时以自己的方式来实现，自己定义方法
4. 子类以父类的身份出现时，子类特有的属性和方法不可以使用
5. 子类可以选择使用`override`关键字，将父类实现替换为它自己的实现，这就是方法重写 `Override`，或者叫作方法覆写
6. 这个对象的声明必须是父类而不是子类，实例化的对象是子类，这才能实现多态

```java
public class Animal {
    public String shout() {
        return "";
    }
}
```

```java
public class Cat extends Animal {
    public Cat() {
        super();
    }
    @override
    public String shout() {
        String result = "";
        result += "喵";
        return result;
    }
}
```

```java
public class Dog extends Animal {
    public Dog() {
        super();
    }
    @override
    public String shout() {
        String result = "";
        result += "汪";
        return result;
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Animal[] arrayAnimal = new Animal[5];
        
        arrayAnimal[0] = new Dog("旺财");
        arrayAnimal[1] = new Cat("加菲");
        
        for(int i=0;i<2;i++) {
            System.out.println(arrayAnimal[i].shout());
        }
    }
}
```



## 重构

1. 将子类中相似的功能提取到父类中，并在子类中继承实现

```java
public class Animal {
    public String shout(){
        String result = "";
        result += getShoutSound();
        return result;
    }
    
    // 只能被子类继承
    protected String getShoutSound() {
        return "";
    }
}
```

```java
public class Cat extends Animal {
     protected String getShoutSound(){
         return "喵";
     }
}
```



## 抽象类

1. **Java**允许把类和方法声明为`abstract`，即抽象类和抽象方法
2. 没有实例化意义的类为抽象类，抽象类不能被实例化
3. 抽象方法必须被子类重写
4. 只要类中有抽象方法那么该类就是抽象类
5. 抽象类要有尽可能多的共同代码，尽可能少的数据
6. 抽象类通常代表一个抽象概念，<u>它提供一个继承的出发点</u>，当设计一个新的抽象类时，**一定是用来继承的**，所以，在一个以继承关系形成的等级结构里面，<u>树叶节点应当是具体类，而树枝节点均应当是抽象类</u>

```java
// 声明一个抽象类，在class前增加abstract关键字
public abstract class Animal {
    // 声明一个抽象方法，且这个方法必须被继承重写实现
    protected abstract String getShoutSound();
}
```



## 接口

1. 接口是用来实现特殊功能
2. 实现接口的类必须实现接口中所有的方法和属性
3. 接口不能实例化，不能有构造函数和字段，不能有修饰符
4. 一个类可以支持多个接口，多个类也可以实现同个接口
5. 接口用`interface`声明，而不是`class`（接口名称前加'I'会更容易识别），接口中的方法或属性前面不能有修饰符、方法没有方法体

```java
public interface IChange {
    public String changeThing(String thing);
}
```

```java
public class MachineCat extends Cat implements IChange {
	public String changeThing(String thing) {
        // this调用当前类中的方法或者属性
        // super()调用父类中的方法或者属性
        return super.shout() + "我有" + thing;
    }
}
```

```java
public class SuperDog extends Dog implements IChange {
	public String changeThing(String thing) {
        // this调用当前类中的方法或者属性
        // super()调用父类中的方法或者属性
        return super.shout() + "我有" + thing;
    }
}
```

你不能直接实例化一个接口，但是你可以创建一个接口的数组，或者一个接口的引用变量，这个变量可以指向实现了该接口的某个类的对象。

```java
public class Test {
	public static void main(String[] args) {
        SuperDog Dog = new SuperDog("旺财");
        MachineCat Cat = new MachineCat("加菲");
        
        // 第一种创建接口变量
        IChange[] array = new IChange[2];
        array[0] = dog;
        array[1] = cat;
        array[0].changeThing("百宝袋");
        array[1].changeThing("千层面");
        
        // 第二种
        IChange DC = Cat;
        DC.changeThing("百宝袋");
    }
}
```

### 接口与抽象类的区别

1. 抽象类可以给出一些成员的实现，接口不包含成员的实现
2. 抽象类的抽象成员可以被子类部分实现，接口的成员需要被实现类完全实现
3. 一个类只能继承一个抽象类，但可以实现多个接口
4. 类是对对象的抽象，抽象类是对类的抽象，接口是对行为的抽象
5. 如果相同对象有不同的功能可使用接口，对于相似的类对象用抽象类



## 集合

先说说数组：

1. "数组的优点，比如说数组在内存中连续存储，因此可以快速而容易地从头到尾遍历元素，可以快速修改元素等"
2. "数组的缺点，应该是创建时必须要指 定数组变量的大小，还有在两个元素之间添加元素也比较困难"

对于集合：

1.  **Java**提供了用于数据存储和检索的专用类，这些类统称集合。这些类提供对堆栈、队列、列表和哈希表的支持

2. 对于`ArrayList`来说，它可以根据使用大小按需动态增加的数组实现`Collection`接口，`ArrayList`的容量是`ArrayList`可以保存的元素数。`ArrayList`的默认初始容量为0。随着元素添加到`ArrayList`中，容量会根据需要通过重新分配自动增加。使用整数索引可以访问此集合中的元素。此集合中的索引从零开始

   ```java
   import java.util.ArrayList;
   public class Test {
       public static void main(String[] args) {
           ArrayList arrayAnimal = new ArrayList();
           // 往集合中增加元素，无论是什么元素都是Object，所以它不安全
           arrayAnimal.add(new Cat("小花"));
           arrayAnimal.add(new Cat("小狗"));
           // 遍历数组
           for(Object item : arrayAnimal) {
               Animal animal = (Animal)item; // 强制将Object转换为Animal对象
               System.out.println(animal.shout());
           }
           
           // 将他们都移除，因为集合的变化是影响全局所以元素始终是连续的
           arrayAnimal.remove(1);
           arrayAnimal.remove(1);
       }
   }
   ```



## 泛型

1. **类型安全**：使用泛型，你可以确保集合中存储的对象类型是你期望的类型，从而避免类型转换异常。
2. **代码复用**：你可以编写一个泛型类或方法，然后多次使用它，每次使用不同的数据类型。
3. **更好的可读性和维护性**：由于类型信息在编译时就被确定了，因此代码更加清晰和易于维护。

```java
import java.util.ArrayList;
public class Test {
    public static void main(String[] args) {
        ArrayList<Animal> arrayAnimal = new ArrayList<Animal>();
        // 往集合中增加元素，无论是什么元素都是Object，所以它不安全
        arrayAnimal.add(new Cat("小花"));
        arrayAnimal.add(new Cat("小狗"));
        // 遍历数组
        for(Animal item : arrayAnimal) {
            System.out.println(item.shout());
        }
        
        // 将他们都移除，因为集合的变化是影响全局所以元素始终是连续的
        arrayAnimal.remove(1);
        arrayAnimal.remove(1);
    }
}
```



# 简单工厂模式

简单工厂模式就是将原本需要在代码中直接实例化对象的过程，抽象化为通过工厂类来创建对象。这样，如果我们需要更改实例化对象的具体类，只需要更改工厂类中的代码，而不需要修改使用这些对象的代码。这有助于降低代码之间的耦合度，提高系统的可扩展性。

![image-20240311102850021](D:\Gitwarehome\Yas\yas-note\java\images\image-20240311102850021.png)

如下面代码所示，用继承和多态的方法扩展工具类，将重要的逻辑代码放在工厂类中，需要哪个方法类就是实例化它

```java
// 运算类
public abstract class Operation {
    public double getResult(double numberA, double numberB) {
        return 0d;
    }
}
```

```java
// 加法类
public class Add extends Operation {
    public double getResult(double numberA, double numberB) {
        return numberA + numberB;
    }
}

// 减法类
public class Sub extends Operation {
    public double getResult(double numberA, double numberB) {
        return numberA - numberB;
    }
}

...
```

```java
// 简单工厂类
public class OperationFactory {
    public static Operation createOperate(String operate) {
        Operation oper = null;
        switch(operate) {
            case "+":
                oper = new Add();
                break;
            case "-":
                oper = new Sub();
                break;
        }
        return oper;
    }
}
```

```java
Operation oper = OperationFactory.createOperate(strOperate);
double result = oper.getResult(numberA, numberB)
```

## 例子

```java
// Shape.java  
public interface Shape {  
    void draw();  
}
```

然后，我们创建实现该接口的具体产品类（例如，圆形和矩形）：

```java
// Circle.java  
public class Circle implements Shape {  
    @Override  
    public void draw() {  
        System.out.println("Inside Circle::draw() method.");  
    }  
}  
  
// Rectangle.java  
public class Rectangle implements Shape {  
    @Override  
    public void draw() {  
        System.out.println("Inside Rectangle::draw() method.");  
    }  
}
```

接下来，我们创建一个工厂类，它负责根据传入的参数创建并返回相应的产品对象：

```java
// ShapeFactory.java  
public class ShapeFactory {  
    // 使用 getShape 方法获取形状类型的对象  
    public Shape getShape(String shapeType) {  
        if (shapeType == null) {  
            return null;  
        }  
        if (shapeType.equalsIgnoreCase("CIRCLE")) {  
            return new Circle();  
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {  
            return new Rectangle();  
        }  
          
        // 默认返回 null  
        return null;  
    }  
}
```

最后，我们有一个客户端代码，它使用工厂类来获取形状对象并调用其方法：

```java
// FactoryPatternDemo.java  
public class FactoryPatternDemo {  
    public static void main(String[] args) {  
        ShapeFactory shapeFactory = new ShapeFactory();  
  
        // 获取 Circle 的对象，并调用它的 draw 方法  
        Shape shape1 = shapeFactory.getShape("CIRCLE");  
  
        // 调用 Circle 的 draw 方法  
        if (shape1 != null) {  
            shape1.draw();  
        }  
  
        // 获取 Rectangle 的对象，并调用它的 draw 方法  
        Shape shape2 = shapeFactory.getShape("RECTANGLE");  
  
        // 调用 Rectangle 的 draw 方法  
        if (shape2 != null) {  
            shape2.draw();  
        }  
    }  
}
```

当你运行`FactoryPatternDemo`类时，你会看到以下输出：

```
Inside Circle::draw() method.  
Inside Rectangle::draw() method.
```

简单工厂模式的优点是客户端代码不需要直接与具体的产品类耦合，它只需要知道工厂类和相应的产品接口。这使得代码更加模块化，并且易于维护和扩展。如果需要添加新的产品类，只需要修改工厂类，而不需要修改客户端代码。

然而，简单工厂模式也有其局限性，例如工厂类负责创建所有产品，这可能导致工厂类变得过于复杂。此外，如果产品类过多，使用简单工厂模式可能会导致违反单一职责原则。在这种情况下，可以考虑使用工厂方法模式或抽象工厂模式来进一步解耦和增加灵活性。

## `UML`类图

![image-20240306171823024](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306171823024.png)

### 矩形框

![image-20240306173227002](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306173227002.png)

一个矩形框代表一个类，类图分三层：

1. 第一层：类的名称，如果是抽象类则是斜体
2. 第二层：类的特性，通常是字段和属性
3. 第三层：类的操作，通常是方法或行为，前面"+"为`public`，"-"为`private`

### 《》接口图

![image-20240306173306247](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306173254292.png)

![image-20240306173324954](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306173324954.png)

这类图以顶端 "《interface》" 来显示，也可以用 "棒棒糖" 的表示方法：

1. 第一层：接口名称
2. 第二层：接口方法

### 继承关系

![image-20240306173616927](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306173616927.png)

父类与子类的继承关系用空心三角形 + 实线来表示

### 实现关系

![image-20240306173703473](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306173703473.png)

接口的实现用空心三角形 + 虚线来表示

### 关联关系

![image-20240306173831740](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306173831740.png)

总之，企鹅需要知道气候的变化，需要了解气候规律

当一个类**知道**另一个类时，可以用**关联（association）**

关联关系用实线箭头来表示

### 聚合关系

![image-20240306174001013](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306174001013.png)

![image-20240306174016959](D:\Gitwarehome\Yas\yas-note\java\images\image-20240306174016959.png)

我们再来看大雁与雁群这两个类，大雁是群居动物，每只大雁都属于一个雁群，一个雁群可以有多只大雁

所以它们之间就满足聚合（Aggregation）关系

聚合表示一种**弱的拥有**关系，体现的是A对象（雁群）可以包含B对象（大雁），但B对象（大雁）不是A对象（雁群）的一部分

聚合关系用空心的菱形 + 实线箭头来表示

### 合成关系

![image-20240307091816271](D:\Gitwarehome\Yas\yas-note\java\images\image-20240307091816271.png)

合成关系又称之为组合，是一种强有的关系，体现了严格的整体与部分的关系。另外，你会注意到合成关系的连线两端还有一个数字'1'和数字'2'，这被称为基数。表明这一端的类可以有几个实例，很显然，一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用'n'来表示

合成关系用实心的菱形 + 实线箭头来表示

### 依赖关系

![image-20240307092108532](D:\Gitwarehome\Yas\yas-note\java\images\image-20240307092108532.png)

动物几大特征，比如有新陈代谢，能繁殖。而动物要有生命力， 需要氧气、水以及食物等。也就是说，动物依赖于氧气和水。它们之间是依赖关系（Dependency）

用虚线箭头来表示



# 策略模式

策略模式（Strategy Pattern）是**Java**中的一种行为设计模式，它定义了一系列的算法，并将每一个算法封装起来，使它们可以互相替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。

策略模式主要有三个组成部分：

1. **环境对象（Context）**：该类中实现了对抽象策略中定义的接口或者抽象类的引用。
2. **抽象策略对象（Strategy）**：它可由接口或抽象类来实现，定义了所有支持算法的公共接口。
3. **具体策略对象（Concrete Strategy）**：它封装了实现同一功能的不同算法，实现了抽象策略定义的接口。

策略模式的优点在于：

- 它提供了可以替换继承关系的办法。
- 使用策略模式可以避免使用多重条件转移语句，使得代码更加清晰易读。
- 策略模式使得算法的变化独立于使用算法的客户，因此可以在运行时动态地改变对象的行为。

策略模式的缺点在于：

- 当策略类数量较多时，所有策略类都需要对外暴露，这可能会增加系统的复杂性。

因此，在使用策略模式时，需要避免过度使用，根据实际需求来选择是否使用策略模式，或者考虑使用混合模式来解决策略类较多的问题。

总的来说，策略模式是一种灵活且强大的设计模式，它可以使代码更加清晰、易于维护和扩展，特别是在需要动态改变对象行为或算法选择的情况下，策略模式会是一个很好的选择。

> 策略模式就是用来封装算法的，但在实践中，我们发现可 以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间 应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性

![image-20240307110046388](D:\Gitwarehome\Yas\yas-note\java\images\image-20240307110046388.png)

```java
// 抽象算法类,前面的修饰符可以自己选择
public abstract class Strategy {
    // 算法方法
    public abstract void algorithmInterface();
}
```

```java
// 具体的算法A
public class ConcreteStrategyA extends Strategy {
    // 算法A实现方法
    public void algorithmInterface() {
        System.out.println("算法A实现");
    }
}
```

```java
// 具体的算法B
public class ConcreteStrategyB extends Strategy {
    // 算法B实现方法
    public void algorithmInterface() {
        System.out.println("算法B实现");
    }
}
```

```java
// 具体的算法C
public class ConcreteStrategyC extends Strategy {
    // 算法C实现方法
    public void algorithmInterface() {
        System.out.println("算法C实现");
    }
}
```

```java
// 上下文类
public class Content {
	private Strategy strategy;
    // 初始化时，传入具体的策略对象
    public Context(String strategy) {
        this.strategy = strategy;
    }
    // 接口上下文
    public void contextInterface() {
        return this.strategy.algorithmInterface();
        // 或
        strategy.algorithmInterface();
    }
}
```

客户端代码

```java
Context context;

// 由于实例化不同的策略，所以最终在调用
// context.contextInterface()时，所
// 获得的结果就不尽相同
context = new Context(new ConcreteStrategyA());
context.contextInterface();

context = new Context(new ConcreteStrategyB());
context.contextInterface();

context = new Context(new ConcreteStrategyC());
context.contextInterface();

// 例
CashContent cc = new CashContent(discount);
totalPrice = cc.getResult(price, num);
total = total + totalPrice;
```

## 银行存款例子

假设一个银行提供多种存款方式，每种存款方式有不同的利率计算策略。例如，活期存款、定期存款（1年期、3年期、5年期等）和特殊存款（如高息存款）等。每种存款方式都需要根据各自的规则来计算利息。

在这个例子中，我们可以使用策略模式来设计这个系统。

首先，我们定义一个`InterestStrategy`接口，它代表计算利息的抽象策略：

```java
public interface InterestStrategy {  
    double calculateInterest(double principal, int duration);  
}
```

接着，我们为每个具体的存款方式实现这个接口，即创建具体的策略对象：

```java
// 活期存款策略  
public class CurrentDepositStrategy implements InterestStrategy {  
    @Override  
    public double calculateInterest(double principal, int duration) {  
        // 根据活期存款的利率规则计算利息  
        double interestRate = 0.003; // 假设活期利率为0.3%  
        return principal * interestRate * duration / 365;  
    }  
}  
  
// 定期存款策略（以1年期为例）  
public class FixedDeposit1YearStrategy implements InterestStrategy {  
    @Override  
    public double calculateInterest(double principal, int duration) {  
        // 根据1年期定期存款的利率规则计算利息  
        double interestRate = 0.02; // 假设1年期定期利率为2%  
        if (duration >= 365) {  
            return principal * interestRate;  
        } else {  
            // 如果不足一年，则可能按照活期利率计算或不给利息  
            return 0;  
        }  
    }  
}  
  
// 其他存款方式的策略实现...
```

然后，我们定义一个`BankAccount`类，它代表银行账户，并持有一个`InterestStrategy`类型的对象引用：

```java
public class BankAccount {  
    private double balance;  // 余额
    private InterestStrategy interestStrategy;  
  
    public BankAccount(double balance, InterestStrategy interestStrategy) {  
        this.balance = balance;  
        this.interestStrategy = interestStrategy;  
    }  
  
    public void setInterestStrategy(InterestStrategy interestStrategy) {  
        this.interestStrategy = interestStrategy;  
    }  
  
    public double getBalance() {  
        return balance;  
    }  
  
    public double calculateInterestForPeriod(int duration) {  
        return interestStrategy.calculateInterest(balance, duration);  
    }  
}
```

最后，客户端代码可以根据需要选择不同的存款策略，并计算利息：

```java
public class BankClient {  
    public static void main(String[] args) {  
        // 创建一个活期存款账户  
        BankAccount currentAccount = new BankAccount(10000, new CurrentDepositStrategy());  
        System.out.println("活期存款利息: " + currentAccount.calculateInterestForPeriod(30));  
  
        // 创建一个1年期定期存款账户  
        BankAccount fixedAccount = new BankAccount(50000, new FixedDeposit1YearStrategy());  
        System.out.println("1年期定期存款利息: " + fixedAccount.calculateInterestForPeriod(365));  
  
        // 如果需要，可以随时更改存款策略  
        currentAccount.setInterestStrategy(new FixedDeposit1YearStrategy());  
        System.out.println("活期存款转为1年期定期后的利息: " + currentAccount.calculateInterestForPeriod(365));  
    }  
}
```

在这个例子中，我们通过使用策略模式，将计算利息的逻辑与银行账户对象解耦。这样，我们可以轻松地添加新的存款方式，而不需要修改`BankAccount`类。同时，客户端代码可以根据需要动态地改变存款策略，使得系统更加灵活和可扩展。

这就是策略模式在银行存款利率计算中的一个具体应用示例。通过策略模式，我们可以实现算法的灵活替换和扩展，提高系统的可维护性和可扩展性。



# 单一职责原则

单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏

当然可以。单一职责原则（Single Responsibility Principle, SRP）是面向对象设计的基本原则之一，它强调一个类应该只有一个引起变化的原因。换句话说，一个类应该只有一个职责，即它应该只做一件事情，并且做好。

下面是一个简单的Java例子，展示了如何应用单一职责原则。

假设我们有一个类`UserManager`，它最初负责用户的创建、更新和删除操作。

```java
// 违反单一职责原则的示例  
public class UserManager {  
      
    // 创建用户  
    public void createUser(User user) {  
        // 创建用户的逻辑  
    }  
      
    // 更新用户信息  
    public void updateUser(User user) {  
        // 更新用户的逻辑  
    }  
      
    // 删除用户  
    public void deleteUser(int userId) {  
        // 删除用户的逻辑  
    }  
      
    // 发送用户欢迎邮件  
    public void sendWelcomeEmail(User user) {  
        // 发送邮件的逻辑  
    }  
}
```

在这个例子中，`UserManager`类不仅负责用户的CRUD操作，还负责发送欢迎邮件。这违反了单一职责原则，因为用户管理（CRUD操作）和发送邮件是两个不同的职责。

为了遵循单一职责原则，我们可以将发送邮件的职责分离出来，创建一个新的类`EmailService`来专门处理邮件发送的逻辑。

```java
// 遵循单一职责原则的示例  
  
// 用户管理类，只负责用户管理相关的操作  
public class UserManager {  
      
    // 创建用户  
    public void createUser(User user) {  
        // 创建用户的逻辑  
    }  
      
    // 更新用户信息  
    public void updateUser(User user) {  
        // 更新用户的逻辑  
    }  
      
    // 删除用户  
    public void deleteUser(int userId) {  
        // 删除用户的逻辑  
    }  
}  
  
// 邮件服务类，只负责发送邮件  
public class EmailService {  
      
    // 发送用户欢迎邮件  
    public void sendWelcomeEmail(User user) {  
        // 发送邮件的逻辑  
    }  
}
```

现在，`UserManager`类只负责用户的CRUD操作，而发送邮件的任务被交给了`EmailService`类。每个类都只负责一个职责，使得代码更加清晰、易于维护和扩展。

在客户端代码中，你可以这样使用这两个类：

```java
public class UserManagementApp {  
    public static void main(String[] args) {  
        UserManager userManager = new UserManager();  
        EmailService emailService = new EmailService();  
          
        User newUser = new User();  
        // ... 设置新用户的信息 ...  
          
        // 创建新用户  
        userManager.createUser(newUser);  
          
        // 发送欢迎邮件  
        emailService.sendWelcomeEmail(newUser);  
    }  
}
```

这样，我们就遵循了单一职责原则，每个类只做一件事情，使得代码结构更加清晰，并且每个类都可以独立地进行修改和测试。

# 开放-封闭原则

开放-封闭原则，是说软件实体（类、模块、函数等）应该可以扩展，但是不可修改。这个原则其实是有两个特征：

1. 对于扩展是开放的 （Open for extension）
2. 对于修改是封闭的（Closed for modification）

在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象类隔离以后发生的同类变化。

<u>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。</u>

**开放-封闭原则**是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。

![image-20240307161714155](D:\Gitwarehome\Yas\yas-note\java\images\image-20240307161714155.png)

开放封闭原则（Open/Closed Principle, OCP）是面向对象设计的基本原则之一，它规定“软件实体（类、模块、函数等等）应当是可扩展，而不可修改的”。也就是说，对于扩展是开放的，对于修改是封闭的。这意味着当我们需要增加新功能时，应该通过添加新的代码（例如新的类或者方法），而不是修改已有的代码。

## 面积计算例子

下面是一个简单的Java例子，展示了如何应用开放封闭原则。

假设我们有一个`Shape`接口和几个实现这个接口的类，如`Circle`和`Square`。现在，我们想要添加一个计算所有形状面积的功能。

首先，我们定义`Shape`接口和它的实现类：

```java
// Shape接口  
public interface Shape {  
    double getArea();  
}  
  
// Circle类实现Shape接口  
public class Circle implements Shape {  
    private double radius;  
  
    public Circle(double radius) {  
        this.radius = radius;  
    }  
  
    @Override  
    public double getArea() {  
        return Math.PI * radius * radius;  
    }  
}  
  
// Square类实现Shape接口  
public class Square implements Shape {  
    private double side;  
  
    public Square(double side) {  
        this.side = side;  
    }  
  
    @Override  
    public double getArea() {  
        return side * side;  
    }  
}
```

现在，假设我们需要添加一个新的形状`Rectangle`，并且希望所有的形状都能被统一地处理。如果我们直接在`Shape`接口中添加新的方法或者修改现有的实现类，那么这就违反了开放封闭原则。

相反，我们应该扩展接口或创建新的类来处理新的需求。这里，我们不需要修改`Shape`接口或已有的实现类，而是可以创建一个新的类来遍历并计算所有形状的面积：

```java
import java.util.List;  
import java.util.ArrayList;  
  
// ShapeAreaCalculator类，负责计算形状的面积  
public class ShapeAreaCalculator {  
    public double calculateTotalArea(List<Shape> shapes) {  
        double totalArea = 0;  
        for (Shape shape : shapes) {  
            totalArea += shape.getArea();  
        }  
        return totalArea;  
    }  
}
```

现在，客户端代码可以这样使用：

```java
public class OpenClosedPrincipleDemo {  
    public static void main(String[] args) {  
        List<Shape> shapes = new ArrayList<>();  
        shapes.add(new Circle(5));  
        shapes.add(new Square(10));  
        // 假设我们将来添加了Rectangle类，我们只需要创建一个新的Rectangle实例并添加到列表中，而不需要修改任何现有代码。  
        // shapes.add(new Rectangle(10, 5));  
  
        ShapeAreaCalculator calculator = new ShapeAreaCalculator();  
        double totalArea = calculator.calculateTotalArea(shapes);  
        System.out.println("Total area: " + totalArea);  
    }  
}
```

在这个例子中，我们添加了`ShapeAreaCalculator`类来计算所有形状的面积。当需要添加新的形状（如`Rectangle`）时，我们只需要实现`Shape`接口并创建一个新的类，然后将新创建的形状实例添加到`shapes`列表中。我们不需要修改`ShapeAreaCalculator`类或其他任何已有代码。这符合开放封闭原则，因为我们扩展了功能（添加新的形状类），而没有修改已有的代码。



# 依赖倒转原则

**依赖倒转原则（Dependency Inversion Principle, DIP）** 是面向对象设计的基本原则之一，它要求<u>高层模块不应该依赖于低层模块，它们都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象</u>。其核心思想是<u>面向接口编程，不要面向实现编程</u>。

在 **Java** 中，实现依赖倒转原则通常通过接口或抽象类来实现。高层模块通过接口或抽象类来引用低层模块，而不是直接引用具体的实现类。这样，高层模块和低层模块之间就建立了松耦合的关系，使得代码更加灵活和可维护。

依赖倒转原则的好处主要有以下几点：

1. **降低耦合度**：通过面向接口编程，减少了类之间的直接依赖，降低了系统的耦合度。
2. **提高可扩展性**：当需要替换低层模块的实现时，只需要修改配置文件或少量代码，而不需要修改高层模块的代码。
3. **易于测试**：由于高层模块不直接依赖于具体的实现类，因此可以更容易地编写单元测试用例来测试高层模块的功能。

在 **Java** 中，可以通过以下方式来实现依赖倒转原则：

1. **定义接口或抽象类**：首先，定义一些接口或抽象类来描述高层模块和低层模块之间的交互方式。
2. **高层模块引用接口或抽象类**：高层模块在代码中只引用接口或抽象类，而不直接引用具体的实现类。
3. **注入实现类**：在运行时，通过配置文件、工厂方法或依赖注入框架等方式将具体的实现类注入到高层模块中。

这样，高层模块和低层模块之间就建立了基于接口或抽象类的依赖关系，实现了依赖倒转原则。

## 支付例子

依赖倒转原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它强调高层模块不应该依赖于低层模块，它们都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。下面是一个简单的Java例子来说明依赖倒转原则的应用。

首先，我们定义一个抽象接口`Payment`，它代表支付功能：

```java
// 抽象接口  
public interface Payment {  
    void pay();  
}
```

接着，我们创建两个实现了`Payment`接口的具体类，`CreditCardPayment`和`CashPayment`，分别代表信用卡支付和现金支付：

```java
// 信用卡支付实现类  
public class CreditCardPayment implements Payment {  
    @Override  
    public void pay() {  
        System.out.println("Paying with credit card...");  
    }  
}  
  
// 现金支付实现类  
public class CashPayment implements Payment {  
    @Override  
    public void pay() {  
        System.out.println("Paying with cash...");  
    }  
}
```

然后，我们创建一个高层模块`Order`，它依赖于`Payment`接口而不是具体的支付实现类：

```java
// 高层模块  
public class Order {  
    private Payment payment;  
  
    public Order(Payment payment) {  
        this.payment = payment;  
    }  
  
    public void checkout() {  
        System.out.println("Checking out the order...");  
        payment.pay(); // 依赖于抽象接口  
    }  
}
```

最后，在客户端代码中，我们根据实际需要创建具体的支付对象，并将其注入到`Order`对象中：

```java
public class DependencyInversionPrincipleDemo {  
    public static void main(String[] args) {  
        // 创建具体的支付对象  
        Payment creditCardPayment = new CreditCardPayment();  
        Payment cashPayment = new CashPayment();  
  
        // 创建订单对象并注入支付对象  
        Order orderWithCreditCard = new Order(creditCardPayment);  
        Order orderWithCash = new Order(cashPayment);  
  
        // 执行结账操作，调用支付功能  
        orderWithCreditCard.checkout(); // 输出：Checking out the order... Paying with credit card...  
        orderWithCash.checkout(); // 输出：Checking out the order... Paying with cash...  
    }  
}
```

在这个例子中，`Order`类是高层模块，它依赖于`Payment`接口这个抽象，而不是依赖于具体的`CreditCardPayment`或`CashPayment`类。这使得`Order`类可以灵活地处理不同的支付方式，只需要将不同的支付对象注入到`Order`对象中即可。这样，如果我们需要添加新的支付方式，比如`DebitCardPayment`，我们只需要实现`Payment`接口，而不需要修改`Order`类或其他已经存在的代码。这就是依赖倒转原则的应用，它使得代码更加灵活、可维护和可扩展。



# 里氏代换原则

**里氏代换原则（Liskov Substitution Principle，LSP）**是面向对象设计的基本原则之一，其核心思想是子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类必须能够替换其父类，并且替换后，程序的行为不会发生变化。

这个原则强调了子类与父类之间的继承关系应该是稳定的，即子类在继承父类时，不应该破坏父类的原有功能。只有当子类可以替换掉父类，且软件的功能不受影响时，父类才能真正被复用，子类也能够在父类的基础上增加新的行为。

里氏代换原则的应用有助于提高代码的重用性、降低代码的耦合性，并使软件更易于维护和扩展。它要求我们在设计类的时候，应该遵循良好的继承规范，确保子类能够正确地替换父类，并且在替换后，不会影响到程序的其他部分。

总的来说，里氏代换原则是面向对象设计中的重要原则，它有助于我们设计出更加健壮、灵活和可维护的软件系统。

![image-20240307165422249](D:\Gitwarehome\Yas\yas-note\java\images\image-20240307165422249.png)

## 动物例子

里氏替换原则（Liskov Substitution Principle，LSP）的一个例子可以帮助我们更好地理解这个原则。假设我们有一个动物（Animal）类，它有一个方法叫“发出声音（makeSound）”。然后我们有两个子类，猫（Cat）和狗（Dog），它们都继承了动物类并重写了“发出声音”方法。

按照里氏替换原则，我们应该能够用子类对象替换父类对象，并且替换后程序的行为不应该发生变化。也就是说，如果我们有一个接受Animal类型参数的函数，我们应该能够传入Cat或Dog类型的对象，而函数的行为应该是一致的。

下面是一个简单的Java代码示例：

```java
// 父类：动物  
class Animal {  
    void makeSound() {  
        System.out.println("The animal makes a sound");  
    }  
}  
  
// 子类：猫  
class Cat extends Animal {  
    @Override  
    void makeSound() {  
        System.out.println("The cat meows");  
    }  
}  
  
// 子类：狗  
class Dog extends Animal {  
    @Override  
    void makeSound() {  
        System.out.println("The dog barks");  
    }  
}  
  
// 示例函数，接受Animal类型参数  
void letAnimalMakeSound(Animal animal) {  
    animal.makeSound();  
}  
  
public class Main {  
    public static void main(String[] args) {  
        Animal myAnimal = new Animal();  
        Cat myCat = new Cat();  
        Dog myDog = new Dog();  
          
        letAnimalMakeSound(myAnimal);  // 输出：The animal makes a sound  
        letAnimalMakeSound(myCat);      // 输出：The cat meows  
        letAnimalMakeSound(myDog);      // 输出：The dog barks  
    }  
}
```

在这个例子中，`letAnimalMakeSound`函数接受一个Animal类型的参数，并调用其`makeSound`方法。我们可以传入Animal类型的对象，也可以传入其子类Cat或Dog的对象，而函数的行为是一致的。这就是里氏替换原则的一个简单示例。它展示了子类可以替换父类，并且在替换后，程序的行为没有发生变化。



# 装饰模式

**装饰模式（Decorator）**动态地给一个对象添加一些额外的职责， 就增加功能来说，装饰模式比生成子类更为灵活。

![image-20240308092520049](D:\Gitwarehome\Yas\yas-note\java\images\image-20240308092520049.png)

`Component` 是定义一个对象接口，可以给这些对象动态地添加职责。 `ConcreteComponent` 是定义了一个具体的对象，也可以给这个对象添加一些 职 责 。 `Decorator` ， 装 饰 抽 象 类 ， 继 承 了 `Component `， 从 外 类 来 扩 展  `Component` 类的功能，但对 `Component` 来说，是无须知道 `Decorator` 的存在的。至于 `ConcreteDecorator` 就是具体的装饰对象，起到给 `Component` 添加职责的功能。

```java
// 定义component抽象类
public abstract Component {
	public abstract void Operation();
}
```

```java
// ConcreteComponent类
public class ConcreteComponent extends Component {
    @override
    public void Operation() {
        System.out.println("具体对象的实际操作");
    }
}
```

```java
public abstract Decorator extends Component {
    protected Component component;
    
    // 装饰一个Component对象
    public void SetComponent(Component component) {
        this.component = component;
    }
    
    // 重写Operation函数(), 实际调用component的Operation方法
    @override
    public void Operation() {
        if(component != null) {
            component.Operation();
        }
    }
}
```

```java
public class ConcreteDecorateA extends Decorator {
    // 本类独有字段，以区别于ConcreteDecoratorB类
    private String addedState;
    
    @override
    public void Operation() {
        super.Operation();
        this.addedState = "具体装饰对象A的独有操作";
        System.out.println(this.addedState);
    }
    
}
```

```java
public class ConcreteDecorateB extends Decorator {
    
    @override
    public void Operation() {
        super.Operation();	// 首先运行了原有的Component的Operation()
        this.AddedBehavior();	// 在执行本类独有功能
    }
    
    // 本类独有方法，以区别于ConcreteDecorateA类
    private void AddedBehavior() {
        System.out.println("具体装饰对象B独有功能");
    }
}
```

客户端

```java
ConcreteComponent c = new ConcreteComponent();
ConcreteComponentA d1 = new ConcreteComponentA();
ConcreteComponentB d2 = new ConcreteComponentB();

d1.SetComponent(c);		// d1来包装c
d2.SetComponent(d1);	// d2来包装d1
d2.Operation();			// 最终执行d2的operation()
```

![image-20240308111243615](D:\Gitwarehome\Yas\yas-note\java\images\image-20240308111243615.png)

```java
// 任务形象接口
public interface ICharacter {
	public void show();
}
```

```java
// 人类
public class Person implements ICharacter {
    private String name;
    public Person(String name) {
        this.name = name;
    }
    @override
    public void show() {
        System.out.println("装扮的" + name);
    }
}
```

```java
// 服饰类
public class Finery implements ICharacter {
    protected ICharacter character;
    
    public void decorate(ICharacter character) {
        this.character = character;
    }
    @override
    public void show() {
        if(this.character != null) {
            this.character.show();
        }
    }
}
```

```java
// 具体服饰类
public class TShirts extends Finery {
    public void show() {
        System.out.println("大T恤");
        super.show();
    }
}
```

客户端代码

```java
Person xc = new Person("小菜");
System.out.println("第一种装扮:");

TShirts tx = new TShirts();
tx.decorate(xc);

BigTrouser kk = new BigTrouser();
kk.decorate(tx);

tx.show();
```

## 简单例子

以下是一个简单的Java装饰模式的例子，我们将创建一个`Component`接口，一个`ConcreteComponent`实现类，以及一个`Decorator`装饰类。

首先，我们定义一个`Component`接口，它代表一个可以被装饰的对象：

```java
public interface Component {  
    void operation();  
}
```

接着，我们实现一个具体的组件类`ConcreteComponent`，它实现了`Component`接口：

```java
public class ConcreteComponent implements Component {  
    @Override  
    public void operation() {  
        System.out.println("执行具体组件的操作");  
    }  
}
```

然后，我们定义一个`Decorator`装饰类，它也实现了`Component`接口，并且内部持有一个`Component`类型的对象引用：

```java
// 装饰类
public class Decorator implements Component {  
    // 要装饰的组件
    private Component component;  
  	// 赋值要装饰的组件
    public Decorator(Component component) {  
        this.component = component;  
    }  
  
    @Override  
    public void operation() {  
        // 在调用具体组件操作之前或之后添加装饰逻辑  
        System.out.println("执行装饰前的操作");  
        component.operation();  
        System.out.println("执行装饰后的操作");  
    }  
}
```

现在，我们可以使用装饰器来增强`ConcreteComponent`的功能：

```java
public class DecoratorPatternDemo {  
    public static void main(String[] args) {  
        // 创建具体组件对象  
        Component concreteComponent = new ConcreteComponent();  
          
        // 使用装饰器增强组件的功能  
        Component decorator = new Decorator(concreteComponent);  
          
        // 执行增强后的操作  
        decorator.operation();  
    }  
}
```

当你运行`DecoratorPatternDemo`的`main`方法时，输出将会是：

```
执行装饰前的操作  
执行具体组件的操作  
执行装饰后的操作
```

在这个例子中，`Decorator`类就是装饰器，它包装了`ConcreteComponent`对象，并在调用`operation`方法时增加了额外的操作。这样，我们就实现了在不修改`ConcreteComponent`代码的情况下，动态地增强了它的功能。这就是装饰模式的基本用法。你可以根据需要创建多个装饰器类，并将它们组合在一起，以实现更复杂的功能增强。



# 简单工厂+策略+装饰模式

![image-20240311102418397](D:\Gitwarehome\Yas\yas-note\java\images\image-20240311102418397.png)

```java
// 所要实现的接口
public interface ISale {
    public double acceptCash(double price, int num);
}
```

```java
// 装饰类
public class CashSuper implements ISale {
    protected ISale component;
    
    // 装饰对象
    public void decorate(ISale component) {
        this.component = component;
    }
    
    public double acceptCash(double price, int num) {
        var result = 0d;
        if(this.component != null) {
            result = this.component.acceptCash(price, num);
        }
        return result;
    }
}
```

```java
// 具体类
public class CashNormal implements ISale {
    // 正常收费，原价返回
    public double acceptCash(double price, int num) {
        return price * num;
    }
}
```

```java
// 具体的装饰对象1
public class CashRebate extends CashSuper {
    private double moneyRebate = 1d;
    // 打折收费。输入折扣率
    public CashRebate(double moneyRate) {
        this.moneyRebate = moneyRate;
    }
    // 折扣率
    public double acceptCash(double price, int num) {
        double result = price * num * this.moneyRebate;
        return super.acceptCash(result, 1);		// 向上传递要包装的数据
    }
}
```

```java
// 具体装饰对象2
public class CashReturn extends CashSuper {
    private double moneyCondition = 0d;
    private double moneyReturn= 0d;
    // 返利收费
    public CashReturn(double moneyCondition, double moneyReturn) {
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }
    // 返利条件
    public double acceptCash(double price, int num) {
        double result = price * num;
        if(moneyCondition > 0 && result >= moneyCondition)
            result = result - Math.floor(result / moneyCondition) * moneyReturn;
        return super.acceptCash(result, 1);		// 用来传递向上传递要包装的数据
    }
}
```

```java
// 策略模式上下文
public class CashContext {
    private ISale cs;
    public CashContext(int cashType) {
        switch(cashType) {
            case 1:
                this.cs = new CashNormal();
                break;
            ...
            case 5:
                // 先打8折，再满300返100
                CashNormal cn = new CashNormal();
                CashReturn cr1 = new CashReturn(300d, 100d);
                CashRebate cr2 = new CashRebate(0.8d);
                cr1.decorate(cn);	// 用满300返100算法包装基本的原价算法
                cr2.decorate(cr1);	// 打8折算法装饰满300返100算法
                this.cs = cr2;		// 将包装好的算法组合引用传递给cs对象
                break;
            case 6:
                // 先满200返50，再打7折
                CashNormal cn2 = new CashNormal();
                CashRebate cr3 = new CashRebate(0.7d);
                CashReturn cr4 = new CashReturn(200d, 50d);
                cr3.decorate(cn2);	// 用打7折算法包装基本的原价算法
                cr4.decorate(cr3);	// 满200减50算法修饰7折算法
                this.cs = cr4;		// 将包装好的算法组合引用传递给cs对象
                break;
        }
    }
    public double getResult(double price, int num) {
        return this.cs.acceptCash(price, num);
    }
}
```

```java
// 客户端调用
CashContext cc = new CashContext(discount);
totalPrice = cc.getResult(price, num);
```

在装饰模式下一层一层的**向上**传递数据来包装最原始的数据集

![image-20240311105745689](D:\Gitwarehome\Yas\yas-note\java\images\image-20240311105745689.png)

# 代理模式

代理模式（Proxy），为其他对象提供一种代理以控制对这个对象的访问。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240311164708135.png" alt="image-20240311164708135" style="zoom:80%;" />

```java
// 定义公共接口ISubject
interface ISubject {
    void request();
}
```

```java
// RealSubject，相当于真正要去建立关系的对象
public class RealSubject implements ISubject {
    public void request() {
        System.out.println("真实的请求。")
    }
}
```

```java
// Proxy类
public class Proxy implements ISubject {
    private RealSubject rs;
    public Proxy() {
        // 代理真正的对象
        this.rs = new RealSubject();
    }
    public void request() {
        this.rs.request();
    }
}
```

```java
// 客户端
Proxy proxy = new Proxy();
proxy.request();
```

使用场景：

1. 远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实
2. 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象
3. 安全代理，用来控制真实对象访问时的权限
4. 智能指引，是指当调用真实的对象时，代理处理另外一些事

## 送礼物列子

![image-20240311161213507](D:\Gitwarehome\Yas\yas-note\java\images\image-20240311161213507.png)

```java
// 送礼物的接口
interface IGiveGift {
    public void giveDolls();
    public void giveFlowers();
    public void giveChocolate();
}
```

```java
// 被追求者
public class SchoolGirl {
    private String name;
    public String getName() {
        return this.name;
    }
    public void setName(String value) {
        this.name = value;
    }
}
```

```java
// 追求者
public class Pursuit implements IGiveGift {
    private SchoolGirl mm;
    public Pursuit(SchooGirl mm) {
        this.mm = mm;
    }
    public void giveDolls() {
        System.out.println(this.mm.getName() + "，你好！送你洋娃娃。");
    }
    public void giveFlowers() {
        System.out.println(this.mm.getName() + "，你好！送你鲜花。");
    }
    public void giveChocolate() {
        System.out.println(this.mm.getName() + "，你好！送你巧克力。");
    }
}
```

```java
// 代理类
public class Proxy implements IGiveGift {
    private Pursuit gg;	// 认识追求者
    public Proxy(SchoolGirl mm) { // 也认识被追求者
        this.gg = new Pursuit(mm);
    }
    public void giveDolls() {
        this.gg.giveDolls();
    }
    public void giveFlowers() {
        this.gg.givegiveFlowers();
    }
    public void giveChocolate() {
        this.gg.giveChocolate();
    }
}
```

```java
// 客户端
SchoolGirl girlLjj = new SchoolGirl();
girlLjj.setName("李娇娇");

Proxy boyDl = new Proxy(girlLjj);
boyDl.giveDolls();
boyDl.giveFlowers();
boyDl.giveChocolate();
```



# 工厂模式

**工厂方法模式（Factory Method）**，定义一个用于创建对象的接口， 让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312093240644.png" alt="image-20240312093240644" style="zoom:80%;" />

## 运算例子

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312094647007.png" alt="image-20240312094647007" style="zoom:80%;" />

```java
// 工厂接口
public interface IFactory {
    public Operation createOperation();
}
```

```java
// 基础运算工厂类
public class FactoryBasic implements IFactory {
    public Operation createOperation(String operType) {
        Operation oper = null;
        switch(operType) {
            case "+":
                oper = new Add();
                break;
            case "-":
                oper = new Sub();
                break;
            case "*":
                oper = new Mul();
                break;
            case "/":
                oper = new Div();
                break;
        }
        return oper;
    }
}
```

```java
// 高级运算工厂类
public class FactoryAdvanced implements IFactory {
    public Operation createOperation(String operType) {
        Operation oper = null;
        switch(operType) {
            case "pow":
                oper = new Pow();
                break;
            case "log":
                oper = new Log();
                break;
                // 可以扩展另外的算法
        }
        return oper;
    }
}
```

```java
// 运算工厂类
public class OperationFactory {
    public static Operation createOperate(String operate) {
        Operation oper = null;
        IFactory factory = null;
        switch(operate) {
            case "+":
            case "-":
            case "*":
            case "/":
                // 基础运算工厂
                factory = new FactoryBasic();
                break;
            case "pow":
            case "log":
                factory = new FactoryAdvanced();
                break;
        }
        oper = factory.createOpeartion(operate);
        return oper;
    }
}
```



# 简单工厂+策略+装饰+工厂模式

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312101105882.png" alt="image-20240312101105882" style="zoom:80%;" />

对上面的银行的业务进行重构

```java
// 增加 IFactory 接口
public interface IFactory {
    public ISale createSalesModel(); // 创建销售模式
}
```

```java
// 先打折再满减类
public class CashRebateReturnFactory implements IFactory {
    private double moneyRate = 1d;
    private double moneyCondition = 0d;
    private double moneyReturn = 0d;
    
    public CashRebateReturnFactory(double moneyRebate, double moneyCondition, double moneyReturn) {
        this.moneyRebate = moneyRebate;
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }
    // 先打x折，再满m返n
    public ISale createSalesModel() {
        CashNormal cn = new CashNormal();
        CashReturn cr1 = new CashReturn(this.moneyCondition, this.moneyReturn);
        CashRebate cr2 = new CashRebate(this.moneyRetur);
        
        cr1.decorate(cn);
        cr2.decorate(cr1);
        return cr2;
    }
}
```

```java
public class CashReturnRebateFactory implements IFactory {
    private double moneyRate = 1d;
    private double moneyCondition = 0d;
    private double moneyReturn = 0d;
    
    public CashReturnRebateFactory(double moneyRebate, double moneyCondition, double moneyReturn) {
        this.moneyRebate = moneyRebate;
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }
    // 先满m返n，再打x折
    public ISale createSalesModel() {
        CashNormal cn2 = new CashNormal();
        CashRebate cr3 = new CashRebate(this.moneyRetur);
        CashReturn cr4 = new CashReturn(this.moneyCondition, this.moneyReturn);
        
        cr3.decorate(cn2);
        cr4.decorate(cr3);
        return cr4;
    }
}
```

```java
public class CashContext {
	private ISale cs;	// 声明一个ISale接口对象
    // 通过构造方法，传入具体的收费策略
    public CashContext(int cashType) {
        IFactory fs = null;
        switch(cashType) {
            case 1:	// 原价
                fs = new CashRebateReturnFactory(1d, 0d, 0d);
                break;
            case 2:// 打8折
                fs = new CashRebateReturnFactory(0.8d, 0d, 0d);
                break;
            case 3:// 打7折
                fs = new CashRebateReturnFactory(0.7d, 0d, 0d);
                break;
            case 4:// 满300返100
                fs = new CashRebateReturnFactory(1, 300d, 100d);
                break;
            case 2:// 先打8折，再满300返100
                fs = new CashRebateReturnFactory(0.8d, 330d, 100d);
                break;
            case 2:// 先满200返50，再打7折
                fs = new CashReturnRebateFactory(0.7d, 200d, 50d);
                break;
        }
        this.cs = fs.createSalesModel();
    }
    public double getResult(double price, int num) {
        return this.cs.acceptCash(price, num);
    }
}
```

## 用反射改造

1. 创建 `data.properties` 

   ```java
   strategy1 = CashRebateReturnFactory,1d,0d,0d
   strategy2 = CashRebateReturnFactory,0.8d,0d,0d
   strategy3 = CashRebateReturnFactory,0.7d,0d,0d
   strategy4 = CashRebateReturnFactory,1d,300d,100d
   strategy5 = CashRebateReturnFactory,0.8d,300d,100d
   strategy6 = CashRebateReturnFactory,0.7d,200d,50d
   ```

2. 修改 `Content` 类

   ```java
   import java.lang.reflect.InvocationTargetException;
   import java.io.BufferedReader;
   import java.io.FileReader;
   import java.io.IOException;
   import java.util.Properties;
   
   public class CashContext {
       private static String assemblyName = "包名";
       
       private ISale cs; // 声明一个ISale接口对象
       
       public CashContext(int cashType) {
           String[] config = getConfig(cashType).split(",");
           IFactory fs = getInstance(config[0], Double.parseDouble(config[1]), Double.parseDouble(config[2]), Double.parseDouble(config[3]));
           this.cs = fs.createSalesModel();
       }
   }
   ```

3. 两个函数包含在 `CashContext` 类中，一个用来读配置文件，一个用来反射生成实例

   ```java
   private String getConfig(int number) {
       String result = "";
       try {
           Properties properties = new Properties();
           // 编译后，将db.properties文件复制到要编译的class目录中，并确保下面patch
           // 路径与实际的db.properties文件路径一致。否则会报错
           String path = System.getProperty("user.dir") + "data.properties文件的路径/data.properties";
           System.out.println("path:" + path);
           BufferedReader bufferedReader = new BufferedReader(new FileReader(path));
           properties.load(bufferedReader);
           result = properties.getProperty("strategy" + number);
       }catch(IOException e) {
           e.printStackTrace();
       } 
       return result;
   }
   
   private IFactory getInstance(String className, double a, double b, double c) {
       IFactory result = null;
       try {
           result = (IFactory)Class
               .forName(assemblyName + className)
               .getDeclaredConstructor(new Class[]{double.class, double.class, double.class})
               .newInstance(new Object[]{a, b, c});
       }catch(InvocationTargetException e) {
           e.printStackTrace();
       }catch(NoSuchMethodException e) {
           e.printStackTrace();
       }catch(InstantiationException e) {
           e.printStackTrace();
       }catch(IllegalAccessException e) {
           e.printStackTrace();
       }catch(ClassNotFoundException e) {
           e.printStackTrace();
       }
       return result;
   }
   ```



# 原型模式

**原型模式（Prototype）**，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。这在对象的创建成本较高或者需要避免大量的构造函数调用时非常有用。

原型模式包含以下几个主要角色：

1. **抽象原型（Prototype）角色**：这是一个接口或抽象类，它声明了克隆自身的方法。
2. **具体原型（Concrete Prototype）角色**：实现了抽象原型中声明的克隆方法，创建具体原型类的克隆对象。
3. **客户端（Client）角色**：根据需要，通过调用具体原型对象的克隆方法来获取原型对象的克隆对象。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312105437497.png" alt="image-20240312105437497" style="zoom:80%;" />

在 **Java** 中，可以使用`Object`类的`clone()`方法来实现对象的浅拷贝。为了使一个类可克隆，需要实现`Cloneable`接口。注意，`Cloneable`接口是一个标记接口，它本身并没有定义任何方法，但是如果一个类没有实现这个接口而直接调用`clone()`方法，那么会抛出`CloneNotSupportedException`异常。

以下是一个简单的Java原型模式的实现示例：

```java
import java.util.Objects;  
  
// 抽象原型角色  
public interface Prototype {  
    Prototype clone();  
}  
  
// 具体原型角色  
public class ConcretePrototype implements Prototype, Cloneable {  
    private String name;  
  
    public ConcretePrototype(String name) {  
        this.name = name;  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    @Override  
    public Prototype clone() {  
        try {  
            return (ConcretePrototype) super.clone();  
        } catch (CloneNotSupportedException e) {  
            throw new Error("This shouldn't happen", e);  
        }  
    }
}  
  
// 客户端角色  
public class Client {  
    public static void main(String[] args) {  
        ConcretePrototype prototype = new ConcretePrototype("Original");  
        Prototype cloned = prototype.clone();  
        System.out.println("Original: " + prototype.getName());  
        System.out.println("Cloned: " + cloned.getName());  
    }  
}
```

在这个例子中，`ConcretePrototype`类实现了`Prototype`接口，并覆盖了`Object`类的`clone()`方法。`Client`类创建了一个`ConcretePrototype`对象，并通过调用其`clone()`方法创建了一个克隆对象。注意，这个示例中的克隆是**浅拷贝**，如果`ConcretePrototype`类包含其他对象引用，那么这些引用也会被共享，而不是创建新的对象。<u>如果需要深拷贝，那么需要实现自定义的克隆逻辑。</u>

这就是Java中原型模式的基本实现。通过原型模式，你可以避免在创建对象时执行大量的初始化代码，从而提高程序的性能。

另一种结构方式：

```java
// 原型类
public class prototype implements Cloneable {
	private String id;
    public Prototype(String id) {
        this.id = id;
    }
    public String getID() {
        return this.id;
    }
    // 原型模式的关键就是有这样一个clone()方法
    public Object clone() {
        Object object = null;
        try {
            object = super.clone();
        } catch(CloneNotSupportedException exception) {
            System.out.println("Clone异常。")
        }
        return object;
    }
}
```

```java
// 具体原型类
public class ConcretePrototype extends Prototype {
    public ConcrePrototype(String id) {
        super(id);
    }
}
```

```java
// 客户端代码
ConcretePrototype p1 = new ConcretePrototype("编号123456");
System.out.println("原ID:" + p1.getID());
ConcretePrototype c1 = (ConcretePrototype)p1.clone();
System.out.println("克隆ID:" + c1.getID());
```

但对于 **Java** 而言，那个原型抽象类 **Prototype** 是用不着的，因为克隆实在是太常用了，所以 **Java** 提供了`Cloneable`接口，其中就是唯一的一个方法`clone()`，这样你就只需要实现这个接口就可以完成原型模式了。

## 浅拷贝与深拷贝

`super.clone()`方法是这样，如果字段是值类型的，则对该字段执行逐位复制，如果字段是引用类型，则复制引用但不复制引用的对象。因此， 原始对象及其副本引用同一对象。

**浅拷贝**：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。

**深拷贝**：深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。

## 浅拷贝例子

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312154403130.png" alt="image-20240312154403130" style="zoom:80%;" />

```java
// 简历类
public class Resume implements Cloneable {
    private String name;
    ... // 另外的个人信息
    public Resume(String name) {
        this.name = name;
    }
    public Resume clone() {
        Resume object = null;
        try {
            object = (Resume)super.clone();
        }catch(CloneNotSupportedException expection) {
            System.err.println("Clone异常。");
        }
        return object;
    }
}
```

```java
// 客户端代码
Resume resume1 = new Resume("高启强");
resume1.setPersonInfo("男", "29");
resume1.setWorkExperience("1998-2000", "小灵通");

Resume resume2= resume1.clone();
resume2.setWorkExperience("2000-2003", "强盛集团");

resume1.display();
/* 高启强 男 29
工作经历: 1998-2000 小灵通
*/
resume2.display();
/* 高启强 男 29
工作经历: 2000-2003 强盛集团
*/
```

## 深拷贝例子

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312155151749.png" alt="image-20240312155151749" style="zoom:80%;" />

```java
public class WorkExperience implements Cloneable{
	private String timeArea;
    public String getTimeArea() {
        return tihs.timeArea;
    }
    public void setTimeArea(String value) {
        this.timeArea = value;
    }
    // 所属公司
    private String company;
    public String getCompany() {
        return this.company;
    }
    public void setCompany(String value) {
        this.company = value;
    }
    
    public WorkExperience clone() {
        WorkExperience object = null;
        try {
            object = (WorkExperience)super.clone();
        }catch(CloneNotSupportException exception) {
            System.err.println("Clone异常");
        }
        return object;
    }
}
```

```java
// 简历类
public class Resume implements Cloneable {
    private String name;
    private WorkExperience work;
    ... // 另外的个人信息
    public Resume(String name) {
        this.name = name;
        this.work = new WorkExperience();
    }
    public Resume clone() {
        Resume object = null;
        try {
            object = (Resume)super.clone();
            object.work = this.work.clone();
        }catch(CloneNotSupportedException expection) {
            System.err.println("Clone异常。");
        }
        return object;
    }
}
```



# 模板方法模式

**模板方法（Template Method）模式**，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312164626672.png" alt="image-20240312164626672" style="zoom:80%;" />

```java
// 模板方法抽象类
public class AbstractClass {
    // 模板方法
    public void templateMethod() {
        // 抽象方法，具体的逻辑组成推迟到子类实现
        this.primitiveOperation1();
        this.primitiveOperation2();
    }
    public abstract void primitiveOperation1();
    public abstract void primitiveOperation2();
}
```

```java
// 模板方法具体类A
public class ConcreteClassA extends AbstractClass {
    public void primitiveOperation1() {
        System.out.println("具体类A方法1实现")
    }
    public void primitiveOperation2() {
        System.out.println("具体类A方法2实现")
    }
}
```

```java
// 模板方法具体类B
public class ConcreteClassB extends AbstractClass {
    public void primitiveOperation1() {
        System.out.println("具体类B方法1实现")
    }
    public void primitiveOperation2() {
        System.out.println("具体类B方法2实现")
    }
}
```

## 试卷例子

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240312170916365.png" alt="image-20240312170916365" style="zoom:80%;" />

```java
// 考试试卷模板
public class TestPaper {
    // 试卷1
    public void testQuestion1() {
        System.out.println("题目1");
        System.out.println("答案：" + this.answer1());
    }
    protected abstract String answer1();
    
    // 试卷2
    public void testQuestion2() {
        System.out.println("题目2");
        System.out.println("答案：" + this.answer2());
    }
    protected abstract String answer2();
    
    // 试卷3
    public void testQuestion3() {
        System.out.println("题目3");
        System.out.println("答案：" + this.answer3());
    }
    protected abstract String answer3();
}
```

```java
// 甲同学的试卷作答
public class TestPaperA extends TestPaper {
    protected String answer1() {
        return "b";
    }
    protected String answer2() {
        return "a";
    }
    protected String answer3() {
        return "c";
    }
}
```

```java
// 乙同学的试卷作答
public class TestPaperB extends TestPaper {
    protected String answer1() {
        return "d";
    }
    protected String answer2() {
        return "b";
    }
    protected String answer3() {
        return "a";
    }
}
```



# 迪米特法则

迪米特法则（Law of Demeter，也称为最少知识原则）是面向对象设计原则中的一个重要原则。它强调一个软件实体应当尽可能少地与其他实体发生相互作用。具体来说，一个对象应该对其他对象有最少的了解。这样做的好处是可以降低对象之间的耦合度，耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。提高系统的可维护性和可重用性。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240313095158094.png" alt="image-20240313095158094" style="zoom:80%;" />

迪米特法则的核心思想主要体现在以下几个方面：

1. **只与直接朋友通信**：每个对象都应当尽量减少与其他对象的交互，只与直接的朋友通信。这里的“直接朋友”通常指的是同一个包（package）中的类，或者具有依赖关系的类。
2. **避免过度暴露内部状态**：一个对象应该尽可能地隐藏其内部状态和实现细节，每一个类都应当尽量降低成员的访问权限，也就是说，一个类包装好自己的 `private` 状态， 不需要让别的类知道的字段或行为就不要公开，只暴露必要的接口或方法给外部。这样可以减少外部对对象内部状态的依赖，降低耦合度。
3. **使用中介者模式**：如果多个对象之间需要相互通信，可以考虑使用中介者模式来降低它们之间的耦合度。中介者模式可以将多个对象之间的交互集中到一个中介者对象中，从而简化对象之间的交互关系。

## 计算器例子

假设我们有一个简单的计算器系统，包含 `Calculator` 、 `Display` 和 `Button` 三个类。按照迪米特法则，我们应该尽量减少 `Button` 和 `Display` 之间的直接通信，而是通过 `Calculator` 作为中介者来进行交互。

```java
// Display类，负责显示计算结果  
public class Display {  
    public void show(int result) {  
        System.out.println("The result is: " + result);  
    }  
}  
  
// Calculator类，作为中介者，负责计算和处理结果  
public class Calculator {  
    private Display display;  
  
    public Calculator(Display display) {  
        this.display = display;  
    }  
  
    public int calculate() {  
        // 执行一些计算逻辑...  
        int result = 42; // 示例结果  
        return result;  
    }  
  
    public void notifyDisplay(int result) {  
        // 通知Display显示结果  
        display.show(result);  
    }  
}  
  
// Button类，代表计算器上的按钮  
public class Button {  
    private Calculator calculator;  
  
    public Button(Calculator calculator) {  
        this.calculator = calculator;  
    }  
  
    public void onClick() {  
        // 当按钮被点击时，通过Calculator来计算结果，而不是直接与Display交互  
        int result = calculator.calculate();  
        // 可以将结果通知给Calculator，由Calculator来决定是否通知Display  
        calculator.notifyDisplay(result);  
    }  
}  
  
// 客户端代码  
public class Client {  
    public static void main(String[] args) {  
        Display display = new Display();  
        Calculator calculator = new Calculator(display);  
        Button button = new Button(calculator);  
  
        // 模拟按钮被点击  
        button.onClick();  
    }  
}
```

在这个例子中，`Button`类不直接与`Display`类交互，而是通过`Calculator`类来间接地通知`Display`显示结果。这样，`Button`和`Display`之间的耦合度降低了，因为`Button`不需要知道`Display`的具体实现细节。同时，`Calculator`作为中介者，可以更容易地管理和控制`Button`和`Display`之间的交互逻辑。

通过遵循迪米特法则，我们可以使代码更加模块化和可维护，降低系统的复杂度，提高代码的可读性和可重用性。



# 外观模式

**外观模式（Facade）**为子系统中的一组接口提供一个一致的界面， 此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240313095719830.png" alt="image-20240313095719830" style="zoom:80%;" />

四个字系统的类：

```java
public class SubSystemOne {
    public void methodOne() {
        System.out.println("子系统方法一");
    }
}
public class SubSystemTwo {
    public void methodTwo() {
        System.out.println("子系统方法二");
    }
}
public class SubSystemThree {
    public void methodThree() {
        System.out.println("子系统方法三");
    }
}
public class SubSystemFour {
    public void methodFour() {
        System.out.println("子系统方法四");
    }
}
```

外观类：

```java
public class Facade {
    SubSystemOne one;
    SubSystemTwo two;
    SubSystemthree three;
    SubSystemFour four;
    
    public Facade() {
        one = new SubSystemOne();
        two = new SubSystemTwo();
        three = new SubSystemthree();
        four = new SubSystemFour();
    }
    
    public void methodA() {
        one.methodOne();
        two.methodTwo();
        three.methodThree();
        four.methodFour();
    }
    
    public void methodB() {
        two.methodTwo();
        three.methodThree();
    }
}
```

客户端：

```java
Facade facade = new Facade();

facade.methodA();
facade.methodB();
```

## 使用场景

1. 在设计初期阶段，应该要有意识地将不同的两个层分离，比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立外观 `Facade` ，这样可以为复杂的子系统提供一个简单的接口，使得耦合大大降低。

   - Java的经典三层架构是一种将应用程序划分为三个主要部分的软件设计模式，这三个部分分别是：表示层（或称为交互层）、业务逻辑层和数据访问层。这种架构模式有助于实现代码的可读性、可维护性和可扩展性，同时提高应用程序的性能和安全性。

     1. **表示层（或交互层）**：这是用户与系统交互的界面，负责接收用户的请求并展示相应的数据和结果。在Web应用程序中，表示层通常由前端技术实现，如HTML、CSS和JavaScript。前端框架如React、Angular、Vue等也被广泛用于简化前端开发和提升用户体验。
     2. **业务逻辑层**：这是应用程序的核心，它位于表示层和数据访问层之间，起到桥梁作用。业务逻辑层负责处理业务逻辑和业务规则，如验证、计算等。Java作为主要的开发语言，用于实现业务逻辑。此外，Java EE框架中的组件，如Servlet、JSP和EJB，也常用于构建业务逻辑层。
     3. **数据访问层**：这一层负责与数据存储系统（如数据库）进行交互，提供数据的读取、写入和更新操作。Java中的 `JDBC`（Java数据库连接）是数据访问层的关键组件，它用于与数据库进行交互。

     除了上述三层，有些架构中还会引入一个**业务实体层（Entity Layer）**，这个层贯穿了所有的层，用于定义业务对象，实现业务数据的封装。

2. 其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是好事，但也给外部调用它们的用户程序带来了使用上的困难，增加外观 `Facade` 可以提供一个简单的接口，减少它们之间的依赖。

3. 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护 和扩展了，但因为它包含非常重要的功能，新的需求开发必须要依赖于它。 此时用外观模式 `Facade` 也是非常合适的。你可以为新系统开发一个外观 `Facade` 类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口， 让新系统与 `Facade` 对象交互，`Facade` 与遗留代码交互所有复杂的工作。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240313110045398.png" alt="image-20240313110045398" style="zoom:80%;" />



# 建造者模式（生成器模式）

**建造者模式（Builder）**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240313111522504.png" alt="image-20240313111522504" style="zoom:80%;" />

- **Builder：**创建一个 `Product` 对象的各个部件指定的抽象接口。
- **ConcreteBuilder：**具体建造者，实现 `Builder` 接口，构造和装配各个部件。
- **Product：**具体的产品。
- **Director：**根据需求构建一个使用Builder接口的对象。

> 构造者主要用于创建一些复杂的对象，这些对象内部的子对象的建造顺序通常是稳定的，但每个子对象本身的构建通常面临着复杂的变化。建造者模式的好处是使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品内部的表示，只需要再定义一个具体的建造者就可以了。

```java
// 产品类
public class Product {
    ArrayList<String> parts = new ArrayList<String>();
    // 添加新的产品部件
    public void add(String part) {
        parts.add(part);
    }
    // 列举所有产品部件
    public void show() {
        for(String part : parts) {
            System.out.println(part);
        }
    }
}
```

```java
// 抽象的建造者类
public class Builder {
	public abstract void buildPartA();	// 建造部件A
	public abstract void buildPartB();	// 建造部件B
	public abstract Product getResult();	// 得到产品
}
```

```java
// 具体建造者1
public ConcreteBuilder1 extends Builder {
    private Product product = new Product();
    public void buildPartA() {
        product.add("部件A");
    }
    public void buildPartB() {
        product.add("部件B");
    }
    public void getResult() {
        return product;
    }
}
```

```java
// 具体建造者2
public ConcreteBuilder2 extends Builder {
    private Product product = new Product();
    public void buildPartA() {
        product.add("部件X");
    }
    public void buildPartB() {
        product.add("部件Y");
    }
    public void getResult() {
        return product;
    }
}
```

```java
// 指挥者类
public class Director {
    public void construct(Builder builder) {
        builder.buildPartA();
        builder.buildPartB();
    }
}
```

```java
// 客户端代码
Director director = new Director();
Builder b1 = new ConcreteBuilder1();
Builder b2 = new ConcreteBuilder2();

// 指挥者用ConcreteBuidler1的方法来建造产品
director.construct(b1);	// 创建的是产品A和产品B
Product p1 = b1.getResult();
p1.show();

// 指挥者用ConcreteBuilder2的方法来建造产品
director.construct(b2);	// 创建的是产品X和产品Y
Product p2 = b2.getResult();
p2.show()
```

# 观察者模式

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240313154208055.png" alt="image-20240313154208055" style="zoom:80%;" />

- **Subject类：**可翻译为主题或抽象通知者，一般用一个抽象类或者一个接口实现。它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。

  ```java
  public class Subject {
      // 针对抽象的 Observer 编程
      private ArrayList<Observer> list = new ArrayList<Observer>();
      // 增加观察者
      public void attach(Observer observer) {
          list.add(observer);
      }
      // 减少观察者
      public void detach(Observer observer) {
          list.remove(observer);
      }
      // 通知观察者
      public void notifyObserver() {
          for(Observer item : list) {
              item.update();
          }
      }
      protected String subjectState;
      public String getSubjectState() {
          return this.subjectState;
      }
      public void setSubjectState() {
          this.subjectState = value;
      }
  }
  ```

- **Observer类：**抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫作更新接口。抽象观察者一般用一个抽象类或者一个接口实现。更新接口通常包含一个`update()`方法，这个方法叫作更新方法。

  ```java
  public abstract class Observe {
  	public abstract void update();
  }
  ```

- **ConcreteSubject类**叫作具体主题或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。

  ```java
  // 具体通知者
  public class ConcreteSubject extends Subject {
      // 具体通知方法
  }
  ```

- **ConcreteObserver类**具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。具体观察者角色可以保存一个指向具体主题对象的引用。具体观察者角色通常用一个具体子类实现。

  ```java
  public ConcreteObserver extends Observer {
  	private String name;
      private Subject sub;
      public ConcreteObserver(String name, Subject sub) {
          this.name = name;
          this.sub = sub;
      }
      public void update() {
          System.out.println("观察者" + this.name + "的新状态是" + this.sub.getSubjectState());
      }
  }
  ```

- 客户端代码

  ```java
  Subject subject = new ConcreteSubject();
  subject.attach(new ConcreteObserver("NameX", subject));
  subject.attach(new ConcreteObserver("NameY", subject));
  subject.attach(new ConcreteObserver("NameZ", subject));
  subject.setSubjectState("ABC");
  
  subject.notifyObserver();
  ```

## Java内置接口

**Java** 已经为观察者模式准备好了相关的接口和抽象类了。观察者接口 `java.util.Observer` 和通知者类 `java.util.Observable`。

在Java中实现观察者模式，通常涉及到`Observable`类和`Observer`接口的使用。以下是一个简单的观察者模式的实现步骤：

1. 定义被观察对象（Observable）

   被观察对象继承自`java.util.Observable`类，并在需要的时候调用`setChanged()`和`notifyObservers()`方法来通知观察者。

   ```java
   import java.util.Observable;  
     
   public class MyObservable extends Observable {  
       // 假设有一个私有变量表示状态  
       private int state;
     
       // 改变状态并通知观察者
       public void setState(int state) {  
           this.state = state;  
           // 标记Observable对象已改变  
           setChanged();  
           // 通知所有观察者  
           notifyObservers(state);  
       }  
     
       // 获取状态  
       public int getState() {  
           return state;  
       }  
   }
   ```

2. 实现观察者（Observer）

   观察者需要实现`java.util.Observer`接口，并覆写`update()`方法。

   ```java
   import java.util.Observable;  
   import java.util.Observer;  
     
   public class MyObserver implements Observer {  
       private String name;
       public MyObserver(String s) {
           this.name = s;
       }
       // 当被观察对象状态改变时调用  
       @Override  
       public void update(Observable o, Object arg) {  
           // arg是被观察对象传递的参数，这里是状态state  
           MyObservable Observable = (MyObservable) o;  
           System.out.println("Observer received state: " + this.name + Observable.getState() + Observable.state);  
           // 在这里执行观察者的逻辑  
       }  
   }
   ```

3. 注册观察者

   在创建被观察对象之后，需要创建观察者对象，并将其注册到被观察对象上。

   ```java
   public class ObserverPatternDemo {  
       public static void main(String[] args) {  
           // 创建被观察对象  
           MyObservable observable = new MyObservable();  
     
           // 创建观察者对象  
           MyObserver observer1 = new MyObserver("a");  
           MyObserver observer2 = new MyObserver("b");  
     
           // 注册观察者  
           observable.addObserver(observer1);  
           observable.addObserver(observer2);  
     
           // 改变被观察对象的状态  
           observable.setState(2); // 这里会触发通知  
       }  
   }
   // 输出，内置的notifyObserver是从后往前遍历
   Observer received state: b:2--2
   Observer received state: a:2--2
   ```

   在上面的例子中，当`MyObservable`对象的`state`状态改变时，它会调用`setChanged()`和`notifyObservers()`方法，通知所有注册的观察者。观察者`MyObserver`的`update()`方法随后会被调用，并接收到传递的状态参数。

4. 注意事项

   - 当你需要自定义通知方式时，可以传递任何类型的参数给`notifyObservers()`方法，这些参数会作为`update()`方法的第二个参数传递给观察者。
   - `Observable`类中的`notifyObservers()`方法有两种形式：无参数版本和带参数版本。带参数版本允许你传递一个额外的参数给观察者，这个参数在`update()`方法中以`Object arg`的形式出现。
   - 如果你不希望继承`Observable`类，而是想要自己定义被观察对象，你可以直接实现观察者模式的接口和逻辑，但这通常需要更多的代码。

   使用Java内置的观察者模式可以简化代码，并减少维护成本，但如果你需要更复杂的通知机制或者更精细的控制，你可能需要实现自定义的观察者模式。



# 抽象工厂模式

**抽象工厂模式（Abstract Factory）**，提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240314101211878.png" alt="image-20240314101211878" />

- **AbstractProductA 与 AbstractProductB：**抽象产品，用于访问数据库表的接口。
- **ProductA1、ProductA2和ProductB1、ProductB2：**对两个抽象产品的具体分类实现，用于实现访问数据库接口中的方法
- **IFactory（AbstractFactory）：**是一个抽象工厂接口，里面应该包含所有产品创建的抽象方法。
- **ConcreteFactory1和ConcreteFactory2：**具体工厂，用于实例化**ProductA1、ProductA2和ProductB1、ProductB2**。

在 **Java** 中，抽象工厂模式是一种创建型设计模式，它提供了一种方式来封装一组具有共同主题的单个工厂，而不需要指定它们的具体类。抽象工厂模式常用于创建一组相互关联或互相依赖的对象，而无需指定它们的具体类。

以下是抽象工厂模式的优点：

1. **隔离具体类**：客户端只需要知道抽象工厂和抽象产品，而不需要知道具体工厂和具体产品，这降低了客户端与具体类之间的耦合度。
2. **易于交换产品系列**：一个具体的工厂类可以在其客户端不改变代码的情况下改变它所创建的产品系列，只需要改变具体的工厂即可。
3. **有利于产品的一致性**：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
4. **提高系统的灵活性和可扩展性**：新的产品族可以很容易地加入到系统中，无需修改已有的系统代码，只需要添加新的具体工厂和具体产品即可。

然而，抽象工厂模式也存在一些缺点：

1. **难以增加新的产品**：抽象工厂模式固定了创建产品的种类，增加新的产品需要修改抽象工厂的接口及其所有实现类，这在一定程度上违背了“开闭原则”。
2. **系统复杂度增大**：由于抽象工厂模式增加了抽象层，使得系统的复杂度增大，理解和实现起来相对困难。
3. **客户端可能需要了解过多的细节**：在客户端代码中，可能需要使用到多个抽象产品，这可能导致客户端代码变得复杂和难以理解。

总的来说，抽象工厂模式在需要创建一组相互关联或互相依赖的对象，且需要保证这些对象的一致性和互换性时非常有用。但在使用时，也需要考虑到其可能带来的系统复杂度和理解难度的增加。在设计系统时，应根据实际需求和系统复杂度权衡使用。

## 访问数据库例子

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240314110954673.png" alt="image-20240314110954673" style="zoom:80%;" />

```java
// 部门类接口
public interface Idepartment(Department department) {
    public void insert(Department department);
    public Department getDepartment(int id);
}
```

```java
// SqlserverDepartment类
public class SqlserverDepartment implements IDepartment {
    // 新增部门
    public void insert(Department department) {
        System.out.println("在SQL Server中插入一条记录");
    }
    // 新增部门信息
    public Department getDepartment(int id) {
        System.out.println("在SQL Server中根据部门ID得到Department表的一条部门记录");
    }
}
```

```java
// AccessDepartment类
public class AccessDepartment implements IDepartment {
    // 新增一个部门
    public void insert(Department department) {
        System.out.println("在Access中插入一条记录")
    }
    // 新增部门信息
    public Department getDepartment(int id) {
        System.out.println("在Access中根据部门ID得到Department表的一条部门记录");
    }
}
```

```java
// 工厂接口
public interface IFactory {
    public IUser createUser();
    public IDpartment createDepartment();
}
```

```java
// Sqlserver工厂
public class SqlserverFactory implements IFactory {
    public IUser createUser() {
        return new SqlserverUser();
    }
    public IDepartment createDepartment() {
        return new SqlserverDepartment();
    }
}
```

```java
// Access工厂
public class AccessFactory implements Ifactory {
    public IUser createUser() {
        return new AccessUser();
    }
    public IDepartment createDepartment() {
        return new AccessDepartment();
    }
}
```

```java
// 客户端代码
User user = new User();
Department department = new Department();

IFactory factory = new SqlserverFactory();

IUser iu = factory.createUser();
iu.insert(user);
iu.getUser(1);

IDepartment idept = factory.createDepartment();
idept.insert(department);
idept.getDepartment(2);
```

## 简单工厂改进抽象工厂

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240314143336183.png" alt="image-20240314143336183" style="zoom:80%;" />

```java
public class DataAccess {
    private static String db = "Sqlserver"; // 数据库名称可替换
    // 创建用户对象工厂
    public static IUser createUser() {
        IUser result = null;
        switch(db) {
            case "Sqlserver":
                result = new SqlserverUser();
                break;
            case "Access":
                result = new AccessUser();
                break;
        }
        return result;
    }
    // 创建部门对象工厂
    public static IDpartment createDepartment() {
         IDpartment result = null;
        switch(db) {
            case "Sqlserver":
                result = new SqlserverDepartment();
                break;
            case "Access":
                result = new AccessDepartmen();
                break;
        }
        return result;
    }
}
```

```java
// 客户端代码
User user = new User();
Department department = new Department();
IUser iu = DataAccess.createUser();

iu.insert(user);	// 新增一个用户
iu.getUser(1);		// 得到用户ID为1的用户信息

IDpartment idept = DataAccess.createDepartment();

idept.insert(department);	// 新增一个部门
idept.getDepartment(2);		// 得到部门ID为2的用户信息
```

## 反射+抽象工厂

格式：

```java
Object result = Class.forName("包名.类名".getDeclaredConstructor().newInstance());
```

例子：

```java
// 常规写法
IUser result = new SqlserverUser();
```

```java
// 反射写法
IUser result = (IUser)Class.forName("code.chapter15.abstractfactory5.SqlserverUser").getDeclaredConstructor().newInstance();
```

```java
public class DataAccess {
	private static String assemblyName = "code.chapter15.abstractfactory5.";
    private static String db = "Sqlserver"; // 数据库名称，可替换成Access
    
    // 创建用户对象工厂
    public static IUser createUser() {
        return (IUser)getInstance(assemblyName + db + "User");
    }
    // 创建部门对象工厂
    public static IDepartment createDepartment() {
        return (IDepartment)getInstance(assemblyName + db + "Department");
    }
    private static Object getInstance(String className) {
        Object result = null;
        try {
            result = Class.forName(className).getDeclaredConstructor().newInstance();
        }catch(InvocationTargetException e) {
            e.printStackTrace();
        }catch(NoSuchMethodException e) {
            e.printStackTrace();
        }catch(InstantiationException e) {
            e.printStackTrace();
        }catch(IllegalAccessException e) {
            e.printStackTrace();
        }catch(ClassNotFoundException e) {
            e.printStackTrace();
        }
        return result;
    }
}
```

## 反射+配置文件实现数据库访问

1. 添加一个`ab.properties`文件

   ```java
   db = Sqlserver
   ```

2. 更改 `DataAccess` 类，添加与读取文件内容相关的包

   ```java
   // 与读文件内容相关的包
   import java.io.BufferedReader;
   import java.io.FileReader;
   import java.io.IOException;
   import java.util.Properties;
   
   public class DataAccess {
       private static String assemblyName = "包名";
       
       public static String getDb() {
           String result = "";
           try {
               Properties properties = new Properties();
               // 编译后，将db.properties文件复制到要编译的class目录中，并确保下面patch
               // 路径与实际的db.properties文件路径一致。否则会报错
               String path = System.getProperty("user.dir") + "db.properties文件的路径/db.properties";
               System.out.println("path:" + path);
               BufferedReader bufferedReader = new BufferedReader(new FileReader(path));
               properties.load(bufferedReader);
               result = properties.getProperty("db");
           }catch(IOException e) {
               e.printStackTrace();
           } 
           return result;
       }
   }
   
   // 创建用户对象工厂
   public static IUser createUser() {
       String db = getDb();
       return (Iuser)getInstance(assemblyName + db + "User");
   }
   ```



# 状态模式

**状态模式（State）**当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。

![image-20240314161102597](D:\Gitwarehome\Yas\yas-note\java\images\image-20240314161102597.png)

```java
// 抽象状态类
public abstract class State {
    public abstract void handle(Context context);
}
```

```java
// 具体状态类A
public class ConcreteStateA extends State {
    public void handle(Context context) {
        context.setState(new ConcreteStateB());
    }
}
// 具体状态类B
public class ConcreteStateB extends State {
    public void handle(Context context) {
        context.setState(new ConcreteStateA());
    }
}
```

```java
// Context类
public class Context {
	private State state;
    public Context(State state) {
        this.state = state;
    }
    // 可读写的状态属性，用于读取当前状态和设置新状态
    public State getState() {
        return this.state;
    }
    public State setState(State value) {
        this.state = value;
        System.out.println("当前状态" + this.state.getClass().getName());
    }
    
    public void request() {
        this.state.handle(this);
    }
}
```

```java
// 客户端代码
Context c = new Context(new ConcreteStateA());

c.request();
c.request();
c.request();
c.request();
```

状态模式的好处是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，它能够消除庞大的条件分支语句，状态模式通过各种状态转移逻辑分布到 `State` 的子类之间，来减少相互间的依赖。

## 工作状态例子

![image-20240314165120861](D:\Gitwarehome\Yas\yas-note\java\images\image-20240314165120861.png)

```java
// 抽象状态类
public abstract class State {
    public abstract void writeProgram(Work w);
}
```

```java
// 上午
public class ForenoonState extends State {
	public void writeProgram(Work w) {
        if(w.getHour() < 12) {
            System.out.println("当前时间：" + w.getHour() + "点 商务工作");
        }else{
            w.setState(new NoonState());
            w.writeProgram();
        }
    }
}
```

```java
// 中午
public class NoonState extends State {
    public void writeProgram(Work w) {
        if(w.getHour() < 13) {
            System.out.println("当前时间：" + w.getHour() + "点 中午吃饭");
        }else{
            w.setState(new AfternoonState());
            w.writeProgram();
        }
    }
}
```

```java
// 下午
public class AfternoonState extends State {
    public void writeProgram(Work w) {
        if(w.getHour() < 17) {
            System.out.println("当前时间：" + w.getHour() + "点 下午摸鱼");
        }else{
            w.setState(new EveningState());
            w.writeProgram();
        }
    }
}
```

```java
// 晚间
public class EveningState extends State {
    public void writeProgram(Work w) {
        if(w.getWorkFinished()) {
            w.setState(new RestState());
            w.writeProgram();
        }else{
            if(w.getHour() < 21) {
                System.out.println("当前时间：" + w.getHour() + "点 加班")
            }else{
                w.setState(new SleepingState());
                w.writeProgram();
            }
        }
    }
}
```

```java
// 睡眠
public class SleepingState extends State {
    public void writeProgram(Work w) {
        System.out.println("当前时间：" + w.getHour() + "点 睡觉")
    }
}
```

```java
// 下班休息
public RestState extends State {
	public void writeProgram(Work w) {
        System.out.println("当前时间：" + w.getHour() + "点 下班")
    }
}
```

```java
// 工作类
public class Work {
    private State current;
    public Work() {
        current = new ForenoonState();
    }
    // 设置状态
    public void setState(State value) {
        this.current = value;
    }
    // 写代码的状态
    public void writeProgram() {
        this.current.writeProgram(this);
    }
    
    // 当前的时间
    private int hour;
    public int getHour() {
        return this.hour;
    }
    public void setHour(int value) {
        this.hour = value;
    }
    // 当前工作是否完成
    private boolean workFinished = false;
    public boolean getWorkFinished() {
        return this.workFinished;
    }
    public void setWorkFinished(boolean value) {
        this.workFinished = value;
    }
}
```

```java
// 客户端代码
Work hotWork = new Work();
hotWork.setHour(9);
hotWork.writeProgram();
...
hotWork.setWorkFinished(false);
hotWork.setWorkFinished(true);

hotWork.writeProgram();
hotWork.setHour(19);
```



# 适配器模式

**适配器模式（Adapter）**将一个类的接口转换成客户希望的另外一个接口。 `Adapter` 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 在软件开发中，也就是系统的数据和行为都正确， 但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。

![image-20240315102333575](D:\Gitwarehome\Yas\yas-note\java\images\image-20240315102333575.png)

```java
// 客户期待的接口
public class Target {
    public void request {
        System.out.println("普通请求！");
    }
}
```

```java
// 需要适配的类
public class Adaptee {
    public void specificRequest() {
        System.out.println("特殊请求！");
    }
}
```

```java
// 适配器类
public Adapter extends Target {
    private Adaptee adaptee = new Adaptee();	// 建立一个私有的Adaptee对哥
    
    public void request() {		// 这样就可以把表面上调用的request()方法
        adaptee.specificRequest();		// 变成实际调用specificRequest()
    }
}
```

```java
// 客户端代码
Target target = new Adapter();
target.request();
```

## 篮球例子

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240315144213747.png" alt="image-20240315144213747" style="zoom:80%;" />

```java
public abstract class Player {
	protected String name;
    public Player(String name) {
        this.name = name;
    }
    public abstract void attack();	// 进攻
    public abstract void defense();	// 防守
}
```

```java
// 前锋
public Forwards extends Player {
	public Forwards(String name) {
        super(name);
    }
    public void attack() {
        System.out.println("前锋" + this.name + "进攻");
    }
    public void defense() {
        System.out.println("前锋" + this.name + "防守");
    }
}
```

```java
// 中锋
public Center extends Player {
    public Center(String name) {
        super(name);
    }
    public void attack() {
        System.out.println("中锋" + this.name + "进攻");
    }
    public void defense() {
        System.out.println("中锋" + this.name + "防守");
    }
}
```

```java
// 后卫
public Guards extends Player {
    public Guards(String name) {
        super(name);
    }
    public void attack() {
        System.out.println("后卫" + this.name + "进攻");
    }
    public void defense() {
        System.out.println("后卫" + this.name + "防守");
    }
}
```

```java
// 外籍中锋
public class ForeignCenter {
    private String name;
    public String getName() {
        return this.name;
    }
    public void setName(String value) {
        this.name = value;
    }
    public void 进攻(){
        System.out.println("外籍中锋" + this.name + "进攻");
    }
    public void 防守(){
        System.out.println("外籍中锋" + this.name + "防守");
    }
}
```

```java
// 翻译者类
public Translator extends Player {
    private ForeignCenter foreignCenter = new ForeignCenter();

    public Translator(String name) {
        super(name);
        foreignCenter.setName(name);
    }

    public void attack() {
        foreignCenter.进攻();
    }

    public void defense() {
        foreignCenter.防守();
    }
}
```

```java
// 客户端代码
Player forwards = new Forwards("巴蒂尔");
forwards.attack();

Player guards = new Guards("巴蒂尔");
guards.attack();

Player center = new Translator("姚明");
center.attack()
center.defense()
```



# 备忘录模式

**备忘录（Memento）：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

![image-20240315152257153](D:\Gitwarehome\Yas\yas-note\java\images\image-20240315152257153.png)

- **Originator（发起人）：**负责创建一个备忘录 `Memento`，用以记录当前时刻它的内部状态，并可使用备忘库恢复内部状态。`Originator` 可根据需要决定存储 `Originator` 的哪些内部状态。
- **Memento（备忘录）：**负责存储 `Originator` 对象的内部状态，并可防止 `Originator` 以外的其他对象访问备忘录 `Memento`。备忘录有两个接口，`Caretaker` 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。`Originator` 能够看到一个宽接口，允许它访问返回到先前状态所需的所有数据。
- **Craetaker（管理者）：** 负责保存好备忘录 `Memento`，不能对备忘录的内容进行操作或检查。

```java
// 发起人
public class Originator {
    // 状态，需要保存的数据
	private String state;
    public String getState() {
        return this.state;
    }
    public void setState(String value) {
        this.state = value;
    }
    // 显示数据
    public void show() {
        System.out.println("State:" + this.state);
    }
    // 创建备忘录
    public Memento createMemento() {
        return new Memento(this.state);
    }
    // 恢复备忘录
    public void recoveryMemento(Memento memento) {
        this.setState(memento.getState);
    }
}
```

```java
// 备忘录
public class Memento {
    private String state;
    
    public Menento(String state) {
        this.state = state;
    }
    
    public String getState() {
        return this.state;
    }
    
    public void setState(String value) {
        this.state = value;
    }
}
```

```java
// 管理者类
public class Caretaker {
    private Memento memento;
    public Memento getMenmento() {
        return this.memento;
    }
    public void setMemento(Memento value) {
        this.memento = value;
    }
}
```

```java
// 客户端程序
Originator o = new Originator();
o.setState("On");
o.show();

Caretaker c = new Caretaker();
// 保存状态时，由于有了很好的封装，可以隐藏 Originator 的实现细节
c.setMemento(o.createMemento());

// Originator 改变了状态属性为"Off"
o.setState("Off");
o.show();

// 恢复原初始状态
o.recoveryMemento(c.getMemento());
o.show();
```

## 游戏进度备忘录

![image-20240315155934587](D:\Gitwarehome\Yas\yas-note\java\images\image-20240315155934587.png)

```java
// 游戏角色
public class GameRole {
    // 生命力
    private int vitality;
    public int getVitality() {
        return this.vitality;
    }
    public void setVitality(int value) {
        this.vitality = value;
    }
    // 攻击力
    private int attack;
    public int getAttack() {
        return this.attack;
    }
    public void setAttack(int value) {
        this.attack = value;
    }
    // 防御力
    private int defense;
    public int getDenfense() {
        return this.defense;
    }
    public void setDefense(int value) {
        this.defense = value;
    }
    // 状态显示
    public void displayState() {
        System.out.println("角色当前状态：");
        System.out.println("体力：" + this.vitality);
        System.out.println("攻击力：" + this.attack);
        System.out.println("防御力：" + this.defense);
        System.out.println();
    }
    // 获取初始状态
    public void getInitState() {
        this.vitality = 100;
        this.attack = 100;
        this.defense = 100;
    }
    // 战斗
    public void fight() {
        this.vitality = 0;
        this.attack = 0;
        this.defense = 0;
    }
    // 保存角色状态
    public RoleStateMemento saveState() {
        return new RoleStateMemento(this.vitality,  this.attack, this.defense);
    }
    // 恢复角色状态
    public void recoveryState(RoleStateMemento memento) {
        this.setVitality(memento.getVitality());
        this.setAttack(memento.getAttack());
        this.setDefense(memento.getDenfense());
    }
}
```

```java
public class RoleStateMemento {
	private int vitality;
	private int attack;
	private int defense;
    // 将生命力、攻击力、防御力存入状态存储对象中
    public RoleStateMemento(int vitality, int attack, int defense) {
        this.vitality;
        this.attack;
        this.defense;
    }
    // 生命力
    public int getVitality() {
        return this.vitality;
    }
    public void setVitality(int value) {
        this.vitality = value;
    }
    // 攻击力
    public int getAttack() {
        return this.attack;
    }
    public void setAttack(int value) {
        this.attack = value;
    }
    // 防御力
    public int getDefense() {
        return this.denfense;
    }
    public int setDefense() {
        this.denfense = value;
    }
}
```

```java
// 角色状态管理者
public class RoleStateCaretaker {
    private RoleStateMemento memento;
    public RoleStateMemento getRoleStateMemento() {
        return this.memento;
    }
    public void setRoleStateMemento(RoleStateMemento value) {
        this.memento = value;
    }
}
```

```java
// 客户端代码
GameRole role = new GameRole();
role.getInitState();
role.displayState();

// 保存进度
RoleStateCaretaker stateAdmin = new RoleStateCaretaker();
stateAdmin.setRoleStateMemento(role.saveState());

// 大战BOSS时
role.fight();
role.displayState();

// 恢复游戏进度
role.recoveryState(stateAdmin.getRoleStateMemento());

// 显示状态
role.displayState();
```



# 组合模式

**组合模式（Composite）**将对象组合成树形结构以表示”**部分 -- 整体**“的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

当你发现需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时， 就应该考虑用组合模式了。

<img src="D:\Gitwarehome\Yas\yas-note\java\images\image-20240316123421072.png" alt="image-20240316123421072" style="zoom:80%;" />

```java
public abstract class Component {
    protected String name;
    public Component(String name) {
        this.name = name;
    }

    public abstract void add(Component component);
    public abstract void remove(Component component);
    public abstract void display(int depth);
}
```

```java
public class Leaf extends Component {
	public Leaf(String name) {
        super(name);
    }
    
    public void add(Component component) {
        System.out.println("Cannot add to a leaf.")
    }
    
    public void remove(Component component) {
        System.out.println("Cannot remove from a leaf.");
    }
    
    public void display(int depth) {
        for(var i=0;i<depth;i++) {
            System.out.println("-");
        }
        System.out.println(name);
    }
}
```

``` java
public Composite extends Component {
    private ArrayList<Component> children = new ArrayList<Component>();
    
    public Composite(String name) {
        super(name);
    }
    
    public void add(Component component) {
        children.add(component);
    }
    public void remove(Component component) {
        children.remove(component);
    }
    public void display(int depth) {
        for(var i=0;i<depth;i++) {
            System.out.println("-");
        }
        System.out.println(name);
        for(Component item : children) {
            item.display(depth + 2);
        }
    }
}
```

```java
// 客户端
Composite root =  new Composite("root");
root.add(new Leaf("Leaf A"));
root.add(new Leaf("Leaf B"));

composite comp = new Composite("Composite X");
comp.add(new Leaf("Leaf XA"));
comp.add(new Leaf("Leaf XB"));
root.add(comp);

composite comp2 = new Composite("Composite XY");
comp.add(new Leaf("Leaf XYA"));
comp.add(new Leaf("Leaf XYB"));
root.add(comp2);

Leaf leaf = new Leaf("Leaf C");
root.add(leaf);

Leaf leaf2 = new Leaf("Leaf D");
root.add(leaf2);
root.remove(leaf2);

root.display(1);
```

![image-20240316125152760](D:\Gitwarehome\Yas\yas-note\java\images\image-20240316125152760.png)

## 公司管理系统例子

![image-20240316131143874](D:\Gitwarehome\Yas\yas-note\java\images\image-20240316131143874.png)

```java
// 公司抽象类
public abstract class Company {
    protected String name;
    public Company(String name) {
        this.name = name;
    }

    public abstract void add(Company company);		// 增加
    public abstract void remove(Company company);	// 移除
    public abstract void display(int depth);		// 显示
    
    public abstract void lineOfDuty(); // 旅行职责
}
```

```java
// 具体分公司类
public class ConcreteCompany extends Company {
    protected ArrayList<Company> children  = new ArrayList<Company>();
    public ConcreteCompany(String name) {
        super(name);
    }
    public void add(Company company) {
        children.add(company);
    }
    public void remove(Company company) {
        children.remove(company);
    }
    public void display(int depth) {
        for(var i=0;i<depth;i++) {
            System.out.println("-");
        }
        System.out.println(name);
        for(Company item : children){
            item.display(depth + 2);
        }
    } 
    // 履行职责
    public void lineOfDuty() {
        for(Company item : children) {
            item.lineOfDuty();
        }
    }
}
```

```java
// 人力资源部，树叶节点
public class HRDepartment extends Company {
    public HRDepartment(String name) {
        super(name);
    }
    public void add(Company company){}
    public void remove(Company company){}
    public void display(int depth) {
        for(var i=0;i<depth;i++) {
            System.out.println("-");
        }
        System.out.println(name);
    }
    public void lineOfDuty() {
        System.out.println(name + "员工招聘培训管理");
    }
}
```

```java
// 人力资源部，树叶节点
public class FinanceDepartment extends Company {
    public FinanceDepartment(String name) {
        super(name);
    }
    public void add(Company company){}
    public void remove(Company company){}
    public void display(int depth) {
        for(var i=0;i<depth;i++) {
            System.out.println("-");
        }
        System.out.println(name);
    }
    public void lineOfDuty() {
        System.out.println(name + "公司财务收支管理");
    }
}
```

```java
// 客户端代码
ConcreteCompany root = new ConcreteCompany("北京总公司");
root.add(new HRDepartment("总公司人力资源部"));
root.add(new FinanceDepartment("总公司财务部"));

ConcreteCompany comp2 = new ConcreteCompany("上海华东分公司");
comp2.add(new HRDepartment("上海华东人力资源部"));
comp2.add(new FinanceDepartment("上海华东分公司财务部"));
root.add(comp2);

System.out.println("结构图：");
root.display(1);
System.out.println("职责：");
root.lineOfDuty();
```



# 迭代器模式

**迭代器模式（Iterator）**，提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。![image-20240316135404839](D:\Gitwarehome\Yas\yas-note\java\images\image-20240316135404839.png)

```java
// 聚合抽象类
public abstract class Aggregate {
	// 创建迭代器
    public abstract Iteractor createIterator();
}
```

```java
// 具体聚集类，继承Aggregate
public class ConcreteAggregate extends Aggregate {
	// 声明一个ArrayList泛型变量，用于存放聚合对象
    private ArrayList<Object> items = new ArrayList<Object>();
    public Iterator createIterator() {
        return new ConcreteIterator(this);
    }
    
    // 返回聚集个数
    public int getCount() {
        return item.size();
    }
    // 新增对象
    public void add(Object object) {
        items.add(object);
    }
    // 得到指定索引对象
    public Object getCurrentItem(int index) {
        return items.get(index);
    }
}
```

```java
// 迭代器抽象类
public abstract class Iterator {
	public abstract Object first();	// 第一个
    public abstract Object next();	// 下一个
    public abstract boolean isDone();	// 是否到最后
    public abstract Object currentItem();	// 当前对象
}
```

```java
// 具体迭代器类，继承Iterator
public class ConcreteIteratpr extends Iterator {
    private ConcreteAggregate aggregate;
    private int current = 0;
    // 初始化时将具体的聚集对象传入
    public ConcreteIterator(ConcreteAggregate aggregate) {
        this.aggregate = aggregate;
    }  
    // 得到第一个对象
    public Object first() {
        return aggregate.getCurrentItem(0);
    }    
    // 得到下一个对象
    public Object next() {
        Object ret = null;
        current++;
        if(current < aggregate.getCount()) {
            ret = aggregate.getCurrentItem(current);
        }
        return ret;
    }  
    // 判断当前是否遍历到结尾，到结尾返回true
    public boolean isDone() {
        return current >= aggregate.getCount() ? true : false;
    }
    // 返回当前的聚集对象
    public Object currentItem() {
        return aggregate.getCurrentItem(current);
    }
}
```

```java
// 客户端代码
ConcreteAggregate alphabet = new ConcreteAggregate();
alphabet.add("a");
alphabet.add("b");
alphabet.add("c");

Iterator conductor = new ConcreteIterator(alphabet);
conductor.first();
while(!conductor.isDone()) {
    System.out.println(conductor.currentItem() + "字母");
    conductor.next();
}
```

## 内置迭代器

**Java** 中的 `forEach` 就是用 `Iterator` 来实现的。

- `Java.util.Iterator` 支持对集合的简单迭代

  ```java
  public interface Iterator {
  	public boolean hasNext();	// 如果迭代具有更多元素，则返回true
      public Object next();		// 返回迭代中的下一个元素
  }
  ```

- `Java.util.ListIterator` 支持对集合任意方向上的迭代

  ```java
  public interface ListIterator {
      public boolean hasNext();
      public Object next();
      
      public boolean hasPrevious();
      public Object previous();
  }
  ```

  **迭代器（Iterator）**模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据。



# 单例模式

**单例模式（Singleton）**保证一个类仅有一个实例，并提供一个访问它的全局访问点。通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。 这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。

![image-20240316145202232](D:\Gitwarehome\Yas\yas-note\java\images\image-20240316145202232.png)

```java
// 单例模式类
public class Singleton {
    private static Singleton instance;
    
    // 构造方法 private 化
    private Singleton() {}
    
    // 得到Singleton的实例（唯一途径）
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

```java
// 客户端代码
Singleton s1 = Singleton.getInstance();
Singleton s2 = Singleton.getInstance();

if(s1 == s2) {
    System.out.println("两个对象是相同的实例");
}
```

单例模式因为**Singleton类**封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。

## 多线程单例

多线程的程序中，多个线程同时，注意是同时访问**Singleton类**，调用`getInstance()`方法，会有可能造成创建多个实例。可以给进程一把锁来处理。这里需要解释一下 `synchronized` 语句的含 义。`synchronized` 是 **Java** 中的关键字，是一种同步锁。意思就是当一个线程没有退出之前，先锁住这段代码不被其他线程代码调用执行，以保证同一时间只有一个线程在执行此段代码。

```java
public class Singleton {
    // volatile关键词是当synchronized变量被初始化成singleton时
    // 多个线程能够正确地处理synchronized变量
	private volatile static Singleton instance;
    
    // 构造方法private化
    private Singleton(){}
    
    // 得到Singleton的实例（唯一途径）
    public static Singleton getInstance() {
        if(instance == null) {
            // 防止多个线程进入创建实例
            synchronized(Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
    }
}
```

## 静态初始化

传统的单例代码会带来巨大的性能代价，静态初始化的方式是在自己被加载时就将自己实例化，所以被形象地称之为**饿汉式单例类**，原先的**单例模式**处理方式是要在第一次被引用时，才会将自己实例化，所以就被称为**懒汉式单例类**。

```java
public class Singleton {
	private static Singleton instance = new Singleton();
    
    // 构造方法private化
    private Singleton(){}
    
    // 得到Singleton的实例（唯一途径）
    public static Singleton getInstance() {
        return instance;
    }
}
```

由于**饿汉式**，即静态初始化的方式，它是类一加载就实例化的对象，所以要提前占用系统资源。

然而**懒汉式**，又会面临着多线程访问的安全性问 =题，需要做双重锁定这样的处理才可以保证安全。



# 桥接模式

**桥接模式（Bridge）**将抽象部分与它的实现部分分离，使它们都可以独立地变化。

![image-20240317152747700](D:\Gitwarehome\Yas\yas-note\java\images\image-20240317152747700.png)

```java
// implementor类
public abstract Implementor {
    public abstract void operation();
}
```

```java
// ConcreteImplementorA与ConcreteImplementorB派生类
public class ConcreteImplementorA extends Implementor {
    public void operation() {
        System.out.println("具体实现A的方法执行");
    }
}

public class ConcreteImplementorB extends Implementor {
    public void operation() {
        System.out.println("具体实现B的方法执行");
    }
}
```

```java
// Abstraction类
public abstract class Abstraction {
    protected Implementor implementor; 
    public void setImplementor(Implementor implementor) {
        this.implementor = implementor;
    }
    public abstract void operation();
}
```

```java
// RefinedAbstraction类
public class RefinedAbstraction extends Abstraction {
	public void operation() {
        System.out.println("具体的Abstraction");
        implementor.operation();
    }
}
```

```java
// 客户端代码
Abstraction ab;
ab = new RefinedAbstraction();

ab.setImplementor(new ConcreteImplementorA());
ab.operation();

ab.setImplementor(new ConcreteImplementorB());
ab.operation();
```

## 合成/聚合复用原则

**合成／聚合复用原则（CARP）**尽量使用合成／聚合，尽量不要使用类继承。

![image-20240317160040982](D:\Gitwarehome\Yas\yas-note\java\images\image-20240317160040982.png)

- **聚合：**表示一种弱的'拥有'关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；

- **合成：**则是一种强的'拥有'关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。

比方说，大雁有两个翅膀，翅膀与大雁是部分和整体的关系，并且它们的生命周期是相同的，于是大雁和翅膀就是合成关系。而大雁是群居动物，所以每只大雁都是属于一个雁群，一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。

合成／聚合复用原则的好处是优先使用对象的合成／聚合将有助于你 保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。

### 手机例子

'手机'既可以按照品牌来分类，也可以按照功能来分类。

![image-20240317160509536](D:\Gitwarehome\Yas\yas-note\java\images\image-20240317160509536.png)

![image-20240317160529129](D:\Gitwarehome\Yas\yas-note\java\images\image-20240317160529129.png)

![image-20240317160306598](D:\Gitwarehome\Yas\yas-note\java\images\image-20240317160306598.png)

"由于实现方式有多种，桥接模式的核心意图是把这些实现独立出来，让 它们各自变化。这就使得每种实现的变化不会影响其他实现，从而达到应对变化的目的。

![image-20240317160334312](D:\Gitwarehome\Yas\yas-note\java\images\image-20240317160334312.png)

```java
// 手机软件
public abstract class HandsetSoft {
	// 运行
    public abstract void run();
}
```

```java
// 手机游戏
public class HandsetGame extends HandsetSoft {
	public void run() {
        System.out.println("手机游戏");
    }
}

// 手机通讯录
public class HandsetAddressList extends HandsetSoft {
    public void run() {
        System.out.println("通讯录");
    }
}
```

```java
// 手机品牌类
public abstract class HandsetBrand {
	protected HandsetSoft soft;
    
    // 设置手机软件
    public void setHandsetSoft(HandsetSoft soft) {
        this.soft = soft;
    }
    
    // 运行
    public abstract void run();
}
```

```java
// 手机品牌类M
public HandsetBrandM extends HandsetBrand {
	public void run() {
        System.out.println("品牌M");
        soft.run();
    }
}
// 手机品牌类N
public class HandsetBrandN extends HandsetBrand {
    public void run() {
        System.out.println("品牌N");
        soft.run();
    }
}
```

```java
// 客户端代码
HandsetBrand ab;
ab = new HandsetBrandM();

ab.setHandsetSoft(new HandsetGame());
ab.run();

ab.setHandsetSoft(new HandsetAddressList());
ab.run();
```



# 命令模式

**命令模式（Command）**将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

![image-20240317163852562](D:\Gitwarehome\Yas\yas-note\java\images\image-20240317163852562.png)

```java
// Command类
public abstract class Command {
    protected Receiver receiver;
    public Command(Receiver receiver) {
        this.receiver = receiver;
    }
    public abstract void excuteCommand();
}
```

```java
// 具体命令类
public class ConcreteCommand extends Command {
	public ConcreteCommand(Receiver receiver) {
        super(receiver);
    }
    public void excuteCommand() {
        receiver.action();
    }
}
```

```java
// Invoker类
public Invoker {
	private Command command;
    public void setCommand(Command command) {
        this.command = command;
    }
    public void executeCommand() {
        command.excuteCommand();
    }
}
```

```java
// Receiver类
public class Receiver {
    public void action() {
        System.out.println("执行请求！");
    }
}
```

```java
// 客户端代码
Receiver receiver = new Receiver();
Command command = new ConcreteCommand(receiver);
Invoker invoker = new Invoker();

invoker.setCommand(command);
invoker.executCommand();
```



## 点餐例子

![image-20240318101117328](D:\Gitwarehome\Yas\yas-note\java\images\image-20240318101117328.png)

```java
// 烤串师傅
public class Barbecuer {
	public void bakeMutton() {
        System.out.println("烤羊肉串!");
    }
    public void bakeChickenWing() {
        System.out.println("烤鸡翅！");
    }
}
```

```java
// 抽象命令类
public abstract class Command {
    // 命令中调用烤串师傅
    protected Barbecuer receiver;
    public Command(Barbecuer receiver) {
        this.receiver = receiver;
    }
    public abstract void excuteCommand();
}
```

```java
// 具体命令类
// 烤羊肉命令类
public class BakeMuttonCommand extends Command {
    public BakeMuttonCommand(Barbecuer receiver) {
        super(receiver);
    }
    public void excuteCommand() {
        receiver.bakeMutton();
    }
}
// 烤鸡翅命令类
public class BakeChickenWingCommand extends Command {
    public BakeChickenWingCommand(Barbecuer receiver) {
        super(receiver);
    }
    public void excuteCommand() {
        receiver.bakeChickenWing();
    }
}
```

```java
// 服务员类
public class Waier {
    private ArrayList<Command> orders = new ArrayList<Command>();
    // 设置订单
    public void setOrder(Command command) {
        String className = command.getClass().getSimpleName();
        if(className.equals("BakeChickenWingCommand")){
            System.out.println("服务员：鸡翅没了，请点别的。")
        }else{
            this.orders.add(command);
            System.out.println("增加订单：" + className + "时间：" + getNowTime());
        }
    }
    // 取消订单
    public void cancelOrder(Command command) {
        String className = command.getClass().getSimpleName();
        orders.remove(command);
        System.out.println("取消订单：" + className + "时间：" + getNowTime());
    }
    // 通知执行
    public void notifyCommand() {
        for(Command command : orders)
        	command.excuteCommand();
    }
    private String getNowTime() {
        SimpleDateFormat formatter = new SimpleDateFormat("HH:mm:ss");
        return formatter.format(new Date()).toString();
    }
}
```

```java
// 客户端代码
Barbecuer boy = new Barbecuer();	// 烤肉师傅
Command bakeMuttonCommand = new BakeMuttonCommand(boy);	// 烤羊肉串
Command bakeChickenWingCommand = new BakeChikenWingCommand(boy); // 烤鸡翅
Waiter girl = new Waiter();	// 服务员

System.out.println("开门营业，顾客点菜");
girl.setOrder(bakeMuttonCommand);	// 下单羊肉串
girl.setOrder(bakeMuttonCommand);	// 下单羊肉串
girl.setOrder(bakeMuttonCommand);	// 下单羊肉串
girl.setOrder(bakeMuttonCommand);	// 下单羊肉串
girl.setOrder(bakeMuttonCommand);	// 下单羊肉串

girl.cancelOrder(bakeMuttonCommand);	// 取消羊肉串

girl.setOrder(bakeChickenWingCommand);	// 下单烤鸡翅

System.out.println("点菜完毕，通知厨房");
girl.notifyCommand();	// 通知厨师
```

![image-20240318104151686](D:\Gitwarehome\Yas\yas-note\java\images\image-20240318104151686.png)

命令模式的作用：

1. 它能较容易地设计一个命令队列
2. 在需要的情况下，可以较容易地将命令记入日志
3. 允许接收请求的一方决定是否要否决请求
4. 可以容易地实现对请求的撤销和重做
5. 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易



# 职责链模式

**职责链模式（Chain of Responsibility）：**使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

![image-20240318151218543](D:\Gitwarehome\Yas\yas-note\java\images\image-20240318151218543.png)

```java
// Handler类，处理请求的接口
public abstract class Handler {
    protected Handler successor;
    
    // 设置继任者
    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }
    public abstract void handleRequest(int request);
}
```

```java
// ConcreteHanlder类，具体处理者类，处理它所负责的请求，可访问它的后继者，如果可处理该请求，就处理之，否则就将该请求转发给它的后继者。
public class ConcreteHandler1 extends Handler {
    public void handleRequest(int request) {
        // 当请求数为0-10则有权处理，否则转移到下一位
        if(request >= 0 && request < 10) {
            System.out.println(this.getClass().getSimpleName() + "处理请求" + request);
        }else if(successor != null){
            successor.handleRequest(request);
        }
    }
}
```

```java
public class ConcreteHandler2 extends Handler {
    public void handleRequest(int request) {
        // 请求数在10-20有权处理
        if(request >= 10 && request < 20){
            System.out.println(this.getClass().getSimpleName()+"处理请求"+request);
        }else if(successor != null){
            successor.handleRequest(request);
        }
    }
}
```

```java
public class ConcreteHandler2 extends Handler {
    public void handleRequest(int request) {
        // 请求数在20-30则有权处理
        if(request >= 20 && request < 30){
            System.out.println(this.getClass().getSimpleName()+"处理请求"+request);
        }else if(successor != null){
            successor.handleRequest(request);
        }
    }
}
```

```java
Handler h1 = new ConcreteHandler1();
Handler h2 = new ConcreteHandler2();
Handler h3 = new ConcreteHandler3();
h1.setSuccessor(h2);
h2.setSuccessor(h3);
int[] requests = {2, 5, 14, 22, 18, 3, 27, 20};

for(int request : resquests){
    h1.handleRequest(request);
}
```

这当中最关键的是当客户提交一个请求时，请求是沿链传递直至有一个`ConcreteHandler`对象负责处理它。这就使得接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。

但要注意的是一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理。

## 加薪例子

![image-20240318153107928](D:\Gitwarehome\Yas\yas-note\java\images\image-20240318153107928.png)

```java
// 管理者抽象类
public abstract class Manager {
    protected String name;
    public Manager(String name){
        this.name = name;
    }
    // 设置管理者上级
    protected Manager superior;
    public void setSuperior(Manager superior) {
        this.superior = superior;
    }
    // 处理请求
    public abstract void requestApplications(Request request);
}
```

```java
// 普通经理
public class CommonManager extends Manager {
    public CommonManager(String name) {
        super(name);
    }
    public void requestApplications(Request request) {
        if(request.getRequestType()=="请假" && request.getNumber()<=2){
            System.out.println(this.name + ":" + request.getRequestContent() + "数量:" + request.getNumber() + "天，被批准");
        }else{
            if(this.superior != null){
                this.superior.requestApplications(request);
            }
        }
    }
```

```java
// 总监
public class Director extends Manager{
    public Director(String name){
        super(name);
    }
    public void requestApplications(Request request) {
        if(request.getRequestType()=="请假" && request.getNumber()<=5){
            System.out.println(this.name + ":" + request.getRequestContent() + "数量:" + request.getNumber() + "天，被批准");
        }else{
            if(this.superior != null){
                this.superior.requestApplications(request);
            }
        }
    }
}
```

```java
// 总经理
public GeneralManager extends Manager{
    public GeneralManager(String name) {
        super(name);
    }
    public void requestApplications(Request request) {
        if(request.getRequestType()=="请假"){
            System.out.println(this.name + ":" + request.getRequestContent() + "数量:" + request.getNumber() + "天，被批准");
        }else if(request.getRequestType()=="加薪" && request.getNumber()<=5000){
            System.out.println(this.name + ":" + request.getRequestContent() + "数量:" + request.getNumber() + "元，被批准");
        }else if(request.getRequestType()=="加薪" && request.getNumber() > 5000){
            System.out.println(this.name + ":" + request.getRequestContent() + "数量:" + request.getNumber() + "元，再说吧");
        }
    }
}
```

```java
// 客户端
CommonManager manager = new CommonManager("周总");
Director director = new Director("华总");
GeneralManager generalManager = new GeneralManager("李总");
manager.setSuperior(director);
director.setSuperior(generalManager);

Request requet = new Request();
request.setRequestType("请假");
request.setRequestContent("小严请假");
request.setNumber(1);
manager.requestAppliacation(request);

Request requet2 = new Request();
request2.setRequestType("请假");
request2.setRequestContent("小严请假");
request2.setNumber(4);
manager.requestAppliacation(request2);

Request requet3 = new Request();
request3.setRequestType("加薪");
request3.setRequestContent("小严请求加薪");
request3.setNumber(5000);
manager.requestAppliacation(request3);

Request requet3 = new Request();
request3.setRequestType("加薪");
request3.setRequestContent("小严请求加薪");
request3.setNumber(10000);
manager.requestAppliacation(request4);
```



# 中介者模式

![image-20240318155313970](D:\Gitwarehome\Yas\yas-note\java\images\image-20240318155313970.png)

**中介者模式（Mediator）**用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可 以独立地改变它们之间的交互。

![image-20240318155447319](D:\Gitwarehome\Yas\yas-note\java\images\image-20240318155447319.png)

```java
// Colleague抽象同事类
public abstract class Colleague {
    protect Mediator mediator;
    // 构造方法，得到中介对象
    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
}
```

```java
// 具体同事类1，而ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但他们却都认识中介者对象
public ConcreteColleague1 extends Colleague {
    public ConcreteColleague1(Mediator mediator) {
        super(mediator);
    }
    public void send(String message) {
        this.mediator.send(message, this);
    }
    public void notify(String message) {
        System.out.println("同事1得到信息：" + message);
    }
}
```

```java
// 具体同事类2，而ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但他们却都认识中介者对象
public ConcreteColleague2 extends Colleague {
    public ConcreteColleague2(Mediator mediator) {
        super(mediator);
    }
    public void send(String message) {
        this.mediator.send(message, this);
    }
    public void notify(String message) {
        System.out.println("同事1得到信息：" + message);
    }
}
```

```java
// 中介者,定义了同事对象到中介者对象的接口
public abstract class Mediator {
	public abstract void send(String message, Colleague colleague);
}
```

```java
// 具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。
public class ConcreteMediator extends Mediator{
    private ConcreteColleague1 colleague1;
    private ConcreteColleague2 colleague2;
    public void setColleague1(ConcreteColleague1 value) {
        this.colleague1 = value;
    }  
    public void setColleague2(ConcreteColleague1 value) {
        this.colleague2 = value;
    }
    public void send(String message, Colleague colleague) {
        if(colleague == colleague1) {
            colleague2.notify(message);
        }else{
            colleague1.notify(message);
        }
    }
}
```

```java
ConcreteMediator m = new ConcreteMediator();
ConcreteColleague1 c1 = new ConcreteColleague1(m);
ConcreteColleague2 c2 = new ConcreteColleague2(m);

m.setColleague1(c1);
m.setColleague2(c2);

c1.send("吃饭了没有？");
c2.send("你请客？");
```

## 联合国例子

![image-20240318161457954](D:\Gitwarehome\Yas\yas-note\java\images\image-20240318161457954.png)

```java
// 国家类
public abstract class Country {
    protected UnitedNations unitedNations;
    public Country(UnitedNations unitedNations) {
        this.unitedNations = unitedNations;
    }
}
```

```java
// 美国
public class USA extends Country {
	public USA(UnitedNations unitedNations) {
        super(unitedNations);
    }
    public void declare(String message) {
        this.unitedNations.declare(message, this);
    }
    public void getMessage(String message) {
        System.out.println("美国获取对方信息：" + message);
    }
}
```

```java
// 伊拉克
public class Iraq extends Country {
    public Iraq(UnitedNations unitedNations) {
        super(unitedNations);
    }
    public void declare(String message) {
        this.unitedNations.declare(message, this);
    }
    public void getMessage(String message) {
        System.out.println("伊拉克获取对方信息：" + message);
    }
}
```

```java
// 联合国机构
public abstract class UnitedNations{
    public abstract void declare(String message, Country country);
}
```

```java
// 联合国安理会
public class UnitedNationsSecurityCouncil extends UnitedNations {
    private USA countryUSA;
    private Iraq countryIraq;
    
    public void setUSA(USA value) {
        this.countryUSA = value;
    }
    public void setIraq(Iraq value) {
        this.countryIraq = value;
    }
    public void declare(String message, Country country) {
        if(country == this.countryUSA) {
            this.countryIraq.getMessage(message);
        }else if(country == this.countryIraq) {
            this.countryUSA.getMessage(message);
        }
    }
}
```

```java
// 客户端调用
UnitedNationsSecurityCouncil UNSC = new UnitedNationsSecurityCouncil();
USA c1 = new USA(UNSC);
Iraq c2 = new Iraq(UNSC);

UNSC.setUSA(c1);
UNSC.serIraq(c2);

c1.declare("不准研制核武器，否则发动战争！");
c2.declare("我们没有核武器，也不怕侵略");
```

中介者模式的优点：

1. **Mediator**的出现减少了各个**Colleague**的耦合，使得可以独立地改变和复用各个**Colleague类**和**Mediator**，比如任何国家的改变不会影响到其他国家，而只是与安理会发生变化。
2. 由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。比如巴以冲突，本来只能算是国与国之间的矛盾，因此各自的看法可能都比较狭隘，但站在联合国安理会的角度，就可以从全球化、也更客观的角度来看待这个问题，在调停和维和上做出贡献。

中介者模式的缺点：

1. 由于**ConcreteMediator**控制了集中化，于是就把交互复杂性变为中介者的复杂性，这就使得中介者会变得比任何一个**ConcreteColleague**都复杂。事实上，联合国安理会秘书长的工作应该是非常繁忙的，谁叫他就 是'全球最大的官'呢。也正因为此，中介者模式的优点来自集中控制，其缺点也是它。



# 享元模式

**享元模式（Flyweight）**运用共享技术有效地支持大量细粒度的对象。

享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。

![image-20240319092552792](D:\Gitwarehome\Yas\yas-note\java\images\image-20240319092552792.png)

- `Flyweight`类是所有具体享元类的超类或接口，通过这个接口 `Flyweight` 可以接受并作用于外部状态。

  ```java
  public abstract class Flyweight {
      public abstract void opeartion(int extrinsicstate);
  }
  ```

- `ConcreteFlyweight` 是继承`Flyweight`超类或实现`Flyweight`接口，并为内部状态增加存储空间。

  ```java
  public class Concreteweight extends Flyweight {
      public void opeartion(int extrinsicstate) {
          System.out.println("具体Flyweight:" + extrinsicstate);
      }
  }
  ```

- `UnsharedConcreteFlyweight`是指那些不需要共享的`Flyweight`子类。因为`Flyweight`接口共享成为可能，但它并不强制共享。

  ```java
  public class UnsharedConcreteFlyweight extends Flyweight {
  	public void operation(int extrinsicstate) {
          System.out.println("不共享的具体Flyweight:" + extrinsicstate);
      }
  }
  ```

- `FlyweightFactory`是一个享元工厂，用来创建并管理`Flyweight`对象。它主要是用来确保合理地共享`Flyweight`，当用户请求一个`Flyweight`时， `FlyweightFactory`对象提供一个已创建的实例或者创建一个（如果不存在的话）。

  ```java
  public class FlyweightFactory {
  	private Hashtable<String, Flyweight> flyweights = new Hashtable<String, Flyweight>();
      public FlyweightFactory() {
          flyweights.put("X", new ConcreteFlyweight());
          flyweights.put("Y", new ConcreteFlyweight());
          flyweights.put("Z", new ConcreteFlyweight());
      }
      Public Flyweight getFlyweight(String key) {
          return (Flyweight)flyweights.get(key);
      }
  }
  ```

```java
// 客户端
int extrinsicstate = 22;

FlyweightFactory f = new FlyweightFactory();

Flyweight fx = f.getFactoryweight("X");
fx.operation(--extrinsicstate);

Flyweight fy = f.getFactoryweight("Y");
fx.operation(--extrinsicstate);

Flyweight fz = f.getFactoryweight("Z");
fx.operation(--extrinsicstate);

Flyweight uf = new UnsharedConcreteFlyweight();

uf.operation(--extrinsicstate);
```



## 网站共享例子

![image-20240319100130981](D:\Gitwarehome\Yas\yas-note\java\images\image-20240319100130981.png)

```java
// 用户类
public class User {
	private String name;
    public User(String value) {
        this.name = value;
    }
    public String getName() {
        return this.name;
    }
}
```

```java
// 网站抽象
public abstract class WebSite {
    public abstract void use(User user);
}
```

```java
// 具体网站
public class ConcreteWebSite extends WebSite {
    private String name = "";
    public ConcreteWebSite(String name) {
        this.name = name;
    }
    public void use(User user){
        System.out.println("网站分类:" + name + "用户:" + user.getName());
    }
}
```

```java
// 网站工厂类
public class WebSiteFactory {
	private Hashtable<String, WebSite> flyweights = new Hashtable<String, WebSite>();
    // 获取网站分类
    public WebSite getWebSiteCategory(String key) {
        if(!flyweights.contains(key))
            flyweights.put(key, new ConcreteWebSite(key));
        return (WebSite)flyweights.get(key);
    }
    // 获取网站分类总数
    public int getWebSiteCount(){
        return flyweights.size();
    }
}
```

```java
// 客户端
WebSiteFactory f = new WebSiteFactory();

WebSite fx = f.getWebSiteCategory("产品展示");
fx.use(new User("a"));

WebSite fx = f.getWebSiteCategory("产品展示");
fx.use(new User("b"));

WebSite fx = f.getWebSiteCategory("博客");
fx.use(new User("c"));

WebSite fx = f.getWebSiteCategory("博客");
fx.use(new User("d"));

System.put.println("网站分类总数为:" + g.getWebSiteCount());// 2
```

- 何时使用享元模式？

  如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。

- 哪些使用了享元模式

  围棋、五子棋、跳棋，`String`类



# 解释器模式

**解释器模式（interpreter）**给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

![image-20240319101721228](D:\Gitwarehome\Yas\yas-note\java\images\image-20240319101721228.png)

- **AbstractExpression（抽象表达式）**声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。

  ```java
  // 抽象表达式
  public class AbstractExpression {
      // 解释操作
      public abstract void interpret(Context context);
  }
  ```

- **TerminalExpression（终结符表达式）**实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个`interpret()`方 法。文法中每一个终结符都有一个具体终结表达式与之相对应。

  ```java
  // 终结符表达式
  public class TerminalExpression extends AbstractExpression {
      public void interpret(Context context) {
          System.out.println("终端解释器");
      }
  }
  ```

- **NonterminalExpression（非终结符表达式）**为文法中的非终结符实现解释操作。对文法中每一条规则R1、R2、…、Rn都需要一个具体的非终结符 表达式类。通过实现抽象表达式的`interpret()`方法实现解释操作。解释操作以递归方式调用上面所提到的代表R1、R2、…、Rn中各个符号的实例变量。

  ```java
  // 非终结符表示器
  public class NonterminalExpression extends AbstractExpression {
      publicvoid interpret(Context context) {
          System.out.println("非终端解释器");
      }
  }
  ```

- 包含解释器之外的一些全局信息

  ```java
  public class Context {
  	private String input;
      public String getInput(){
          return this.input;
      }
      public void setInput(String value) {
          this.input = value;
      }
      
      private String output;
      public String getOutput() {
          return this.output;
      }
      public void setOutput(String value) {
          this.output = value;
      }
  }
  ```

- 客户端代码

  ```java
  Context context = new Context();
  ArrayList<AbstractExpression> list = new ArrayList<AbstractExpression>();
  list.add(new TerminalExpression());
  list.add(new NonterminalExpression());
  list.add(new TerminalExpression());
  list.add(new TerminalExpression());
  
  for(AbstractExpression exp : list) {
      exp.interpret(context);
  }
  ```



# 访问者模式

**访问者模式（Visitor）**表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

![image-20240319104331784](D:\Gitwarehome\Yas\yas-note\java\images\image-20240319104331784.png)

访问者模式的目的是要把处理从数据结构分离出来。很多系统可以按照算法和数据结构分开，如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。反之，如果这样的系统的数据结构对象易于变化， 经常要有新的数据对象增加进来，就不适合使用访问者模式。

访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。

- **Visitor类**为该对象结构中`ConcreteElement`的每一个类声明一个 `Visit` 操作。

  ```java
  // Visitor
  public abstract class Visitor {
      public abstract void visitConcreteElementA(concreteElementA concreteElementA);
      public abstract void visitConcreteElementB(concreteElementA concreteElementB);
  }
  ```

- **ConcreteVisitor1和ConcreteVisitor2类**：具体访问者，实现每个由 `Visitor` 声明的操作。每个操作实现算法的一部分，而该算法片断乃是对应于结构中对象的类。

  ```java
  public class ConcreteVisitor1 extends Visitor {
      public void visitConcreteElementA(concreteElementA concreteElementA){
          System.out.println(concreteElementA.getClass().getSimpleName() + "被" + this.getClass().getSimpleName() + "访问");
      }
      public void visitConcreteElementB(concreteElementB concreteElementB){
          System.out.println(concreteElementB.getClass().getSimpleName() + "被" + this.getClass().getSimpleName() + "访问");
      }
  }
  ```

- **Element类**：定义一个Accept操作，它以一个访问者为参数。

  ```java
  public abstract class Element {
  	public abstract void accept(Visitor visitor);
  }
  ```

- **ConcreteElementA和ConcreteElementB类**：具体元素，实现`Accept`操作。

  ```java
  public class ConcreteElementA extends Element {
      public void accpet(Visitor visitor) {
          visitor.visitConcreteElementA(this);
      }
      public void opeartionA(){}
  }
  
  public class ConcreteElementB extends Element {
      public void accpet(Visitor visitor) {
          visitor.visitConcreteElementB(this);
      }
      public void opeartionB(){}
  }
  ```

- **ObjectStructure类**：能枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。

  ```java
  public class ObjectStruct {
      private ArrayList<Element> elements = new ArrayList<Element>();
      public void attach(Element element) {
          element.add(element);
      }
      public void detach(Element element) {
          element.remove(element);
      }
      public void accept(Visitor visitor) {
          for(Element e : elements) {
              e.accept(visitor);
          }
      }
  }
  ```

- 客户端代码

  ```java
  ObjectStructure o = new ObjectStructure();
  o.attch(new ConcreteElementA());
  o.attch(new ConcreteElementB());
  
  ConcreteVisitor1 v1 = new ConcreteVisitor1();
  ConcreteVisitor2 v2 = new ConcreteVisitor2();
  
  o.accept(v1);
  o.accept(v2);
  ```



## 性别例子

![image-20240319104207608](D:\Gitwarehome\Yas\yas-note\java\images\image-20240319104207608.png)

```java
// 状态抽象类
public abstract class Action {
    // 得到男人结论或反应
    public abstract void getManConclusion(Man concreteElmentA);
    // 得到女人结论或反应
    public abstract void getWoManConclusion(WoMan concreteElmentB);
}
```

```java
// 状态类
public class Success extends Action {
    public void getManConclusion(Man concreteElementA) {
        System.out.println(concreteElementA.getClass().getSimpleName() + " " + this.getClass().getSimpleName() + "时，背后多半有个伟大的女人");
    }
    public void getWoManConclusion(WoMan concreteElmentB) {
        System.out.println(concreteElementB.getClass().getSimpleName() + " " + this.getClass().getSimpleName() + "时，背后多半有个男人");
    }
}
```

```java
// 人类抽象类
public abstract class Person {
    // 接受
    public abstract void accept(Action visitor); 
}
```

```java
// 男人类
public class Man extends Person {
	public void accept(Action visitor) {
        visitor.getManConclusion(this);
    }
}
// 女人类
public class Woman extends Person {
    public void accept(Action visitor) {
        visitor.getWomanConclusion(this);
    }
}
```

```java
public class ObjectStructure {
	private ArrayList<Person> elements = new ArrayList<Person>();    
    // 增加
    public void attach(Person element) {
        elements.add(element);
    }
    // 移除
    public void detach(Person element) {
        elements.remove(element);
    }
    // 查看显示
    public void display(Action visitor) {
        for(Person e : elements) {
            e.accept(visitor);
        }
    }
}
```

```java
// 客户端代码
ObjectStructure o = new ObjectStructure();
o.attach(new Man());
o.attach(new Woman());

// 成功时的反应
Success v1 = new Success();
o.display(v1);

// 失败时的反应
Failing v2 = new Failing();
o.display(v2);
```

